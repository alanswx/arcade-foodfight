//-------------------------------------------------------------------
//
//   This file is automatically generated by VHDL to Verilog Translator.
//         Ver.1.24 thanks to T.I. Build May.8.2006
//               www.sugawara-systems.com   
//                    tech-support@sugawara-systems.com
//        See Original Copyright Notice for property of the file .( somewhere in this file.)
//
//--------------------------------------------------------------------


//--------------------------------------------------------------------
//--                                                              ----
//-- MC68000 compatible IP Core					                  ----
//--                                                              ----
//-- This file is part of the SUSKA ATARI clone project.          ----
//-- http://www.experiment-s.de                                   ----
//--                                                              ----
//-- Description:                                                 ----
//-- This model provides an opcode and bus timing compatible ip   ----
//-- core compared to Motorola's MC68000 microprocessor.          ----
//--                                                              ----
//-- This file contains the 68Ks bus interface unit.              ----
//--                                                              ----
//-- This file contains the 68Ks bus interface unit.              ----
//--                                                              ----
//-- Description:                                                 ----
//-- This module provides bus control during read cycles, write   ----
//-- cycles and read modify write cycles. It also provides 2 and  ----
//-- 3 wire bus arbitration control, halt and rerun operation,    ----
//-- bus and address error generation, wait state insertion and   ----
//-- synchronous bus operation (68000).                           ----
//-- In the following there are some remarks on the working       ----
//-- principle of this core.                                      ----
//--                                                              ----
//-- Bus cycle operation:                                         ----
//-- A bus cycle is released by either asserting RD_BUS for       ----
//-- entering a read cycle or WR_BUS for entering a write cycle.  ----
//-- There must not be asserted both signals at the same time.    ----
//-- Once the bus cycle is started, the RD_BUS or the WR_BUS      ----
//-- must be asserted until the cycle finishes. This is indicated ----
//-- by the signal BUS_CYC_RDY, which is valid for one clock      ----
//-- cycle after the bus operation finished.                      ----
//--                                                              ----
//-- Synchronous timing topics:                                   ----
//-- During the synchronous timing, the DTACKn must not be        ----
//-- asserted and due to asynchronous timing, the VPAn must not   ----
//-- be asserted, otherwise unpredictable behavior will result.   ----
//--                                                              ----
//-- Bus arbitration topics:                                      ----
//-- No bus arbitration during read modify write cycle.           ----
//-- In the case of a 2 wire bus arbitration, no re-entry for     ----
//--   another device is possible.                                ----
//--                                                              ----
//-- Bus error topics:                                            ----
//-- During a bus error, the bus cycle finishes also asserting    ----
//-- the BUS_CYC_RDY signal during S7.                            ----
//--                                                              ----
//-- Bus re-run topics:                                           ----
//-- During a re-run condition, the bus cycle finishes also       ----
//-- asserting the BUS_CYC_RDY signal during S7.                  ----
//--                                                              ----
//-- RESET topics:                                                ----
//-- When a reset is released by the CPU due to the RESET_EN      ----
//-- control, the RESET_RDY indicates the finishing of the reset  ----
//-- cycle 124 clock cycles later. The RESET_EN may be asserted   ----
//-- until RESET_RDY indicates 'ready'. The RESET_RDY is a strobe ----
//-- and therefore valid for one clock cycle.                     ----
//--                                                              ----
//-- Author(s):                                                   ----
//-- - Wolfgang Foerster, wf@experiment-s.de; wf@inventronik.de   ----
//--                                                              ----
//--------------------------------------------------------------------
//--                                                              ----
//-- Copyright (C) 2006 - 2011 Wolfgang Foerster                  ----
//--                                                              ----
//-- This source file is free software; you can redistribute it   ----
//-- and/or modify it under the terms of the GNU General Public   ----
//-- License as published by the Free Software Foundation; either ----
//-- version 2 of the License, or (at your option) any later      ----
//-- version.                                                     ----
//--                                                              ----
//-- This program is distributed in the hope that it will be      ----
//-- useful, but WITHOUT ANY WARRANTY; without even the implied   ----
//-- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ----
//-- PURPOSE.  See the GNU General Public License for more        ----
//-- details.                                                     ----
//--                                                              ----
//-- You should have received a copy of the GNU General Public    ----
//-- License along with this program; if not, write to the Free   ----
//-- Software Foundation, Inc., 51 Franklin Street, Fifth Floor,  ----
//-- Boston, MA 02110-1301, USA.                                  ----
//--                                                              ----
//--------------------------------------------------------------------
// 
// Revision History
// 
// Revision 2K6B  2006/12/24 WF
//   Initial Release.
// Revision 2K7A  2007/05/31 WF
//   Updated all modules.
// Revision 2K7B  2007/12/24 WF
//   See the 68K00 top level file.
// Revision 2K8A  2008/07/14 WF
//   See the 68K00 top level file.
// Revision 2K8B  2008/12/24 WF
//   Fixed a minor bug in the RESET operation.
//   Changes regarding the read modify write logic of the TAS operation.
//   Several changes to provide correct bus arbitration.
// Revision 2K9A  2009/06/20 WF
//   Changed the E_TIMER process concerning synchronous reset.
//   ADR_EN logic is now synchronous.
//   Various changes concerning HALTn, RESET_CPUn, RD_BUS and WR_BUS.
// Revision 2K9B  2009/12/24 WF
//   Fixed a timing bug in the bus arbitration state register.
//   Fixed UDSn and LDSn logic not working correct with waitstates in some cases.
// Revision 2K11A 20110620 WF
//   Removed EXEC_ABORT from the entity.
// Revision 2K11B 20111226 WF
//   Some updates concerning inactive signals during HALT assertion.
//   Minor changes in the BERRn logic.
//   Fixed BUS_CYC_RDY logic during the HALT or retry operation.
// Revision 2K13A 20130620 WF
//   Fixed the VMAn timing. Thanks to Igor Majstorovic for the information.
//


module  wf68k00ip_bus_interface ( clk, resetn, reset_inn, reset_out_en, reset_cpun, reset_en, reset_rdy, data_in, sel_a_hi, sel_a_midhi, sel_a_midlo, sel_a_lo, sel_buff_a_lo, sel_buff_a_hi, sel_buff_b_lo, sel_buff_b_hi, sys_init, op_size, buffer_a, buffer_b, data_core_out, rd_bus, wr_bus, tas_lock, a0, byten_word, bus_cyc_rdy, data_valid, dtackn, berrn, avecn, haltn, adr_en, wr_hi, hi_word_en, hi_byte_en, lo_byte_en, fc_en, asn, as_en, udsn, uds_en, ldsn, lds_en, rwn, rw_en, vpan, vman, vma_en, e, brn, bgackn, bgn );
    //type op_sizetype
     parameter long__op_sizetype=2'd0;
     parameter word__op_sizetype=2'd1;
     parameter byte__op_sizetype=2'd2;
     
//type d_sizetype
     parameter long__d_sizetype=2'd0;
     parameter word__d_sizetype=2'd1;
     parameter byte__d_sizetype=2'd2;
     
//type op_68k00
     parameter abcd__op_68k00=7'd0;
     parameter add__op_68k00=7'd1;
     parameter adda__op_68k00=7'd2;
     parameter addi__op_68k00=7'd3;
     parameter addq__op_68k00=7'd4;
     parameter addx__op_68k00=7'd5;
     parameter and_b__op_68k00=7'd6;
     parameter andi__op_68k00=7'd7;
     parameter andi_to_ccr__op_68k00=7'd8;
     parameter andi_to_sr__op_68k00=7'd9;
     parameter asl__op_68k00=7'd10;
     parameter asr__op_68k00=7'd11;
     parameter bcc__op_68k00=7'd12;
     parameter bchg__op_68k00=7'd13;
     parameter bclr__op_68k00=7'd14;
     parameter bra__op_68k00=7'd15;
     parameter bset__op_68k00=7'd16;
     parameter bsr__op_68k00=7'd17;
     parameter btst__op_68k00=7'd18;
     parameter chk__op_68k00=7'd19;
     parameter clr__op_68k00=7'd20;
     parameter cmp__op_68k00=7'd21;
     parameter cmpa__op_68k00=7'd22;
     parameter cmpi__op_68k00=7'd23;
     parameter cmpm__op_68k00=7'd24;
     parameter dbcc__op_68k00=7'd25;
     parameter divs__op_68k00=7'd26;
     parameter divu__op_68k00=7'd27;
     parameter eor__op_68k00=7'd28;
     parameter eori__op_68k00=7'd29;
     parameter eori_to_ccr__op_68k00=7'd30;
     parameter eori_to_sr__op_68k00=7'd31;
     parameter exg__op_68k00=7'd32;
     parameter extw__op_68k00=7'd33;
     parameter illegal__op_68k00=7'd34;
     parameter jmp__op_68k00=7'd35;
     parameter jsr__op_68k00=7'd36;
     parameter lea__op_68k00=7'd37;
     parameter link__op_68k00=7'd38;
     parameter lsl__op_68k00=7'd39;
     parameter lsr__op_68k00=7'd40;
     parameter move__op_68k00=7'd41;
     parameter movea__op_68k00=7'd42;
     parameter move_from_ccr__op_68k00=7'd43;
     parameter move_to_ccr__op_68k00=7'd44;
     parameter move_from_sr__op_68k00=7'd45;
     parameter move_to_sr__op_68k00=7'd46;
     parameter move_usp__op_68k00=7'd47;
     parameter movem__op_68k00=7'd48;
     parameter movep__op_68k00=7'd49;
     parameter moveq__op_68k00=7'd50;
     parameter muls__op_68k00=7'd51;
     parameter mulu__op_68k00=7'd52;
     parameter nbcd__op_68k00=7'd53;
     parameter neg__op_68k00=7'd54;
     parameter negx__op_68k00=7'd55;
     parameter nop__op_68k00=7'd56;
     parameter not_b__op_68k00=7'd57;
     parameter or_b__op_68k00=7'd58;
     parameter ori__op_68k00=7'd59;
     parameter ori_to_ccr__op_68k00=7'd60;
     parameter ori_to_sr__op_68k00=7'd61;
     parameter pea__op_68k00=7'd62;
     parameter reset__op_68k00=7'd63;
     parameter rotl__op_68k00=7'd64;
     parameter rotr__op_68k00=7'd65;
     parameter roxl__op_68k00=7'd66;
     parameter roxr__op_68k00=7'd67;
     parameter rte__op_68k00=7'd68;
     parameter rtr__op_68k00=7'd69;
     parameter rts__op_68k00=7'd70;
     parameter sbcd__op_68k00=7'd71;
     parameter scc__op_68k00=7'd72;
     parameter stop__op_68k00=7'd73;
     parameter sub__op_68k00=7'd74;
     parameter suba__op_68k00=7'd75;
     parameter subi__op_68k00=7'd76;
     parameter subq__op_68k00=7'd77;
     parameter subx__op_68k00=7'd78;
     parameter swap__op_68k00=7'd79;
     parameter tas__op_68k00=7'd80;
     parameter trap__op_68k00=7'd81;
     parameter trapv__op_68k00=7'd82;
     parameter tst__op_68k00=7'd83;
     parameter unlk__op_68k00=7'd84;
     parameter reserved__op_68k00=7'd85;
     parameter unimplemented__op_68k00=7'd86;
     

    input  [0:0] clk;
    input  [0:0] resetn;
    input  [0:0] reset_inn;
    output  [0:0] reset_out_en;
    output  [0:0] reset_cpun;
    input  [0:0] reset_en;
    output  [0:0] reset_rdy;
    input [15:0]  data_in ;
    input  [0:0] sel_a_hi;
    input  [0:0] sel_a_midhi;
    input  [0:0] sel_a_midlo;
    input  [0:0] sel_a_lo;
    input  [0:0] sel_buff_a_lo;
    input  [0:0] sel_buff_a_hi;
    input  [0:0] sel_buff_b_lo;
    input  [0:0] sel_buff_b_hi;
    input  [0:0] sys_init;
    input  [1:0] op_size;
    output [31:0]  buffer_a ;
    output [31:0]  buffer_b ;
    output [15:0]  data_core_out ;
    input  [0:0] rd_bus;
    input  [0:0] wr_bus;
    input  [0:0] tas_lock;
    input a0;
    input  [0:0] byten_word;
    output  [0:0] bus_cyc_rdy;
    output  [0:0] data_valid;
    input  [0:0] dtackn;
    input  [0:0] berrn;
    input  [0:0] avecn;
    input haltn;
    output  [0:0] adr_en;
    input  [0:0] wr_hi;
    output  [0:0] hi_word_en;
    output  [0:0] hi_byte_en;
    output  [0:0] lo_byte_en;
    output  [0:0] fc_en;
    output  [0:0] asn;
    output  [0:0] as_en;
    output  [0:0] udsn;
    output  [0:0] uds_en;
    output  [0:0] ldsn;
    output  [0:0] lds_en;
    output  [0:0] rwn;
    output  [0:0] rw_en;
    input  [0:0] vpan;
    output  [0:0] vman;
    output  [0:0] vma_en;
    output  [0:0] e;
    input  [0:0] brn;
    input  [0:0] bgackn;
    output  [0:0] bgn;


    reg [3:0] e_timer__tmp;
    reg [3:0] reset_filter__tmp;
    reg [6:0] reset_timer__tmp;
reg [0:0] reset_timer__lock;
//type arb_states
    parameter idle__arb_states=2'd0;
    parameter grant__arb_states=2'd1;
    parameter wait_release_3wire__arb_states=2'd2;
    
//type time_slices
    parameter s0__time_slices=3'd0;
    parameter s1__time_slices=3'd1;
    parameter s2__time_slices=3'd2;
    parameter s3__time_slices=3'd3;
    parameter s4__time_slices=3'd4;
    parameter s5__time_slices=3'd5;
    parameter s6__time_slices=3'd6;
    parameter s7__time_slices=3'd7;
    
reg [0:0] reset_out_en_i =0; 
reg [0:0] reset_cpu_in =0; 
reg [1:0] arb_state;
reg [1:0] next_arb_state;
wire [2:0] t_slice;
    reg [1:0] slice_cnt;
wire [0:0] berr;
wire [0:0] fc_enab;
reg [0:0] vma_in =0; 
reg [0:0] uds_rd_en_n =0; 
reg [0:0] uds_rd_en_p =0; 
wire [0:0] uds_rd_en;
reg [0:0] lds_rd_en_n =0; 
reg [0:0] lds_rd_en_p =0; 
wire [0:0] lds_rd_en;
reg [0:0] uds_wr_en_n =0; 
reg [0:0] uds_wr_en_p =0; 
wire [0:0] uds_wr_en;
reg [0:0] lds_wr_en_n =0; 
reg [0:0] lds_wr_en_p =0; 
wire [0:0] lds_wr_en;
reg [0:0] as_enab_n =0; 
reg [0:0] as_enab_p =0; 
wire [0:0] as_enab;
reg [0:0] adr_en_n =0; 
reg [0:0] adr_en_p =0; 
reg [0:0] data_en_n =0; 
reg [0:0] data_en_p =0; 
wire [0:0] data_en;
reg [0:0] wr_enab_p =0; 
wire [0:0] wr_enab;
reg [0:0] waitstates =0; 
reg [0:0] syncn =0; 
wire [0:0] reset_out_en;
wire [0:0] reset_cpun;
reg [0:0] reset_rdy =0; 
    reg [31:0] buffer_a;
    reg [31:0] buffer_b;
    reg [15:0] data_core_out;
wire [0:0] bus_cyc_rdy;
wire [0:0] data_valid;
wire [0:0] adr_en;
wire [0:0] hi_word_en;
wire [0:0] hi_byte_en;
wire [0:0] lo_byte_en;
wire [0:0] fc_en;
wire [0:0] asn;
wire [0:0] as_en;
wire [0:0] udsn;
wire [0:0] uds_en;
wire [0:0] ldsn;
wire [0:0] lds_en;
wire [0:0] rwn;
wire [0:0] rw_en;
wire [0:0] vman;
wire [0:0] vma_en;
reg [0:0] e =0; 
wire [0:0] bgn;


    
   assign {uds_en}=((t_slice == s0__time_slices) & (haltn == 1'b0)) ? 
                       1'b0
                    : (arb_state == idle__arb_states) ? 
                       1'b1
                    :  1'b0;
   
   assign {lds_en}=((t_slice == s0__time_slices) & (haltn == 1'b0)) ? 
                       1'b0
                    : (arb_state == idle__arb_states) ? 
                       1'b1
                    :  1'b0;
   
   assign {as_en}=((t_slice == s0__time_slices) & (haltn == 1'b0)) ? 
                      1'b0
                   : (arb_state == idle__arb_states) ? 
                      1'b1
                   :  1'b0;
   
   assign {rw_en}=((t_slice == s0__time_slices) & (haltn == 1'b0)) ? 
                      1'b0
                   : (arb_state == idle__arb_states) ? 
                      1'b1
                   :  1'b0;
   
   assign {fc_en}=((t_slice == s0__time_slices) & (haltn == 1'b0)) ? 
                      1'b0
                   : (tas_lock == 1'b1) ? 
                      1'b1
                   :  fc_enab;
   
   assign {uds_wr_en}=(uds_wr_en_n | uds_wr_en_p);
   
   assign {lds_wr_en}=(lds_wr_en_n | lds_wr_en_p);
   
   assign {uds_rd_en}=(uds_rd_en_n | uds_rd_en_p);
   
   assign {lds_rd_en}=(lds_rd_en_n | lds_rd_en_p);
   
   assign {as_enab}=(as_enab_n | as_enab_p);
   
   assign {wr_enab}=wr_enab_p;
   
   assign {data_en}=(data_en_n | data_en_p);
   
   assign {adr_en}=(!(arb_state==idle__arb_states)) ? 
                       1'b0
                    : ((t_slice == s0__time_slices) & (haltn == 1'b0)) ? 
                       1'b0
                    : (tas_lock == 1'b1) ? 
                       1'b1
                    :  (adr_en_n | adr_en_p);
   
   assign {fc_enab}=(!(arb_state==idle__arb_states)) ? 
                        1'b0
                     : (tas_lock == 1'b1) ? 
                        1'b1
                     : (((rd_bus == 1'b0) & (wr_bus == 1'b0)) & (t_slice == s0__time_slices)) ? 
                        1'b0
                     :  1'b1;
   
   assign {vma_en}=(!(arb_state==idle__arb_states)) ? 
                       1'b0
                    :  1'b1;
   
   assign {vman}=vma_in;
   
   assign {bgn}=(arb_state == grant__arb_states) ? 
                    1'b0
                 :  1'b1;
   
   assign {data_valid}=(t_slice == s6__time_slices) ? 
                           1'b1
                        :  1'b0;
   
       
   always @ (negedge resetn or negedge clk ) // begin 
           if ((resetn == 1'b0)) 
               begin 
                   buffer_a <= {(31-0+1- 0){1'b0}};
                   buffer_b <= {(31-0+1- 0){1'b0}};
               end
               
           else 
               
                   begin 
                       if (((((t_slice == s6__time_slices) & (sel_a_hi == 1'b1)) & (a0 == 1'b0)) & (rd_bus == 1'b1))) 
                           buffer_a[31:24] <= data_in[15:8];
                           
                       else if ((((t_slice == s6__time_slices) & (sel_a_hi == 1'b1)) & (rd_bus == 1'b1))) 
                           buffer_a[31:24] <= data_in[7:0];
                           
                       else if (((((t_slice == s6__time_slices) & (sel_a_midhi == 1'b1)) & (a0 == 1'b0)) & (rd_bus == 1'b1))) 
                           buffer_a[23:16] <= data_in[15:8];
                           
                       else if ((((t_slice == s6__time_slices) & (sel_a_midhi == 1'b1)) & (rd_bus == 1'b1))) 
                           buffer_a[23:16] <= data_in[7:0];
                           
                       else if (((((t_slice == s6__time_slices) & (sel_a_midlo == 1'b1)) & (a0 == 1'b0)) & (rd_bus == 1'b1))) 
                           buffer_a[15:8] <= data_in[15:8];
                           
                       else if ((((t_slice == s6__time_slices) & (sel_a_midlo == 1'b1)) & (rd_bus == 1'b1))) 
                           buffer_a[15:8] <= data_in[7:0];
                           
                       else if (((((t_slice == s6__time_slices) & (sel_a_lo == 1'b1)) & (a0 == 1'b0)) & (rd_bus == 1'b1))) 
                           buffer_a[7:0] <= data_in[15:8];
                           
                       else if ((((t_slice == s6__time_slices) & (sel_a_lo == 1'b1)) & (rd_bus == 1'b1))) 
                           buffer_a[7:0] <= data_in[7:0];
                           
                       else if ((((t_slice == s6__time_slices) & (sys_init == 1'b1)) & (sel_buff_a_hi == 1'b1))) 
                           buffer_a[31:16] <= data_in;
                           
                       else if ((((t_slice == s6__time_slices) & (sys_init == 1'b1)) & (sel_buff_a_lo == 1'b1))) 
                           buffer_a[15:0] <= data_in;
                           
                       else if (((((t_slice == s6__time_slices) & (sel_buff_a_lo == 1'b1)) & (op_size == byte__op_sizetype)) & (a0 == 1'b0))) 
                           buffer_a <= {24'h000000,data_in[15:8]};
                           
                       else if ((((t_slice == s6__time_slices) & (sel_buff_a_lo == 1'b1)) & (op_size == byte__op_sizetype))) 
                           buffer_a <= {24'h000000,data_in[7:0]};
                           
                       else if (((t_slice == s6__time_slices) & (sel_buff_a_lo == 1'b1))) 
                           buffer_a[15:0] <= data_in;
                           
                       else if (((t_slice == s6__time_slices) & (sel_buff_a_hi == 1'b1))) 
                           buffer_a[31:16] <= data_in;
                           
                       else if (((((t_slice == s6__time_slices) & (sel_buff_b_lo == 1'b1)) & (op_size == byte__op_sizetype)) & (a0 == 1'b0))) 
                           buffer_b <= {24'h000000,data_in[15:8]};
                           
                       else if ((((t_slice == s6__time_slices) & (sel_buff_b_lo == 1'b1)) & (op_size == byte__op_sizetype))) 
                           buffer_b <= {24'h000000,data_in[7:0]};
                           
                       else if (((t_slice == s6__time_slices) & (sel_buff_b_lo == 1'b1))) 
                           buffer_b[15:0] <= data_in;
                           
                       else if (((t_slice == s6__time_slices) & (sel_buff_b_hi == 1'b1))) 
                           buffer_b[31:16] <= data_in;
                           
                       
                       if ((t_slice == s6__time_slices)) 
                           data_core_out <= data_in;
                           
                       
                       
                   end
                   
               
           
   // end always 
   
   assign {berr}=(((((berrn == 1'b0) & (haltn == 1'b1)) & (!(t_slice==s0__time_slices))) & (!(t_slice==s1__time_slices))) & (!(t_slice==s2__time_slices))) ? 
                     1'b1
                  : ((((((berrn == 1'b0) & (haltn == 1'b0)) & (tas_lock == 1'b1)) & (!(t_slice==s0__time_slices))) & (!(t_slice==s1__time_slices))) & (!(t_slice==s2__time_slices))) ? 
                     1'b1
                  :  1'b0;
   
   assign {bus_cyc_rdy}=(((t_slice == s6__time_slices) | (t_slice == s7__time_slices)) & ((haltn == 1'b1) | (berrn == 1'b1))) ? 
                            1'b1
                         :  1'b0;
   
   assign {asn}=(as_enab == 1'b1) ? 
                    1'b0
                 :  1'b1;
   
   assign {udsn}=((((rd_bus == 1'b1) & (uds_rd_en == 1'b1)) & (a0 == 1'b0)) & (byten_word == 1'b0)) ? 
                     1'b0
                  : ((((wr_bus == 1'b1) & (uds_wr_en == 1'b1)) & (a0 == 1'b0)) & (byten_word == 1'b0)) ? 
                     1'b0
                  : (((rd_bus == 1'b1) & (uds_rd_en == 1'b1)) & (byten_word == 1'b1)) ? 
                     1'b0
                  : (((wr_bus == 1'b1) & (uds_wr_en == 1'b1)) & (byten_word == 1'b1)) ? 
                     1'b0
                  :  1'b1;
   
   assign {ldsn}=((((rd_bus == 1'b1) & (lds_rd_en == 1'b1)) & (a0 == 1'b1)) & (byten_word == 1'b0)) ? 
                     1'b0
                  : ((((wr_bus == 1'b1) & (lds_wr_en == 1'b1)) & (a0 == 1'b1)) & (byten_word == 1'b0)) ? 
                     1'b0
                  : (((rd_bus == 1'b1) & (lds_rd_en == 1'b1)) & (byten_word == 1'b1)) ? 
                     1'b0
                  : (((wr_bus == 1'b1) & (lds_wr_en == 1'b1)) & (byten_word == 1'b1)) ? 
                     1'b0
                  :  1'b1;
   
   assign {rwn}=((wr_bus == 1'b1) & (wr_enab == 1'b1)) ? 
                    1'b0
                 :  1'b1;
   
   assign {hi_word_en}=(((wr_bus == 1'b1) & (data_en == 1'b1)) & (wr_hi == 1'b1)) ? 
                           1'b1
                        :  1'b0;
   
   assign {hi_byte_en}=((((wr_bus == 1'b1) & (data_en == 1'b1)) & (a0 == 1'b0)) & (byten_word == 1'b0)) ? 
                           1'b1
                        : (((wr_bus == 1'b1) & (data_en == 1'b1)) & (byten_word == 1'b1)) ? 
                           1'b1
                        :  1'b0;
   
   assign {lo_byte_en}=((((wr_bus == 1'b1) & (data_en == 1'b1)) & (a0 == 1'b1)) & (byten_word == 1'b0)) ? 
                           1'b1
                        : (((wr_bus == 1'b1) & (data_en == 1'b1)) & (byten_word == 1'b1)) ? 
                           1'b1
                        :  1'b0;
   
   always begin
       begin 
           @(negedge clk );
           if ((t_slice == s4__time_slices)) 
                   waitstates <= ((((dtackn & syncn) & avecn) & ~ (berr)) & reset_cpu_in);
           else 
                   waitstates <= 1'b0;

           
       end
    end
   
       
   always @ (negedge resetn or posedge clk ) // begin 
           if ((resetn == 1'b0)) 
               slice_cnt <= 2'b00;
               
           else 
               
                   if ((!(arb_state==idle__arb_states))) 
                       slice_cnt <= 2'b00;
                       
                   else if (((rd_bus == 1'b0) & (wr_bus == 1'b0))) 
                       slice_cnt <= 2'b00;
                       
                   else if (((slice_cnt == 2'b00) & (haltn == 1'b0))) 
                       slice_cnt <= 2'b00;
                       
                   else if ((waitstates == 1'b0)) 
                       slice_cnt <= (slice_cnt + 1'b1);
                       
                   
                   
               
           
   // end always 
   
   assign {t_slice}=((rd_bus == 1'b0) & (wr_bus == 1'b0)) ? 
                        s0__time_slices
                     : ((slice_cnt == 2'b00) & (clk == 1'b1)) ? 
                        s0__time_slices
                     : (((slice_cnt == 2'b00) & (clk == 1'b0)) & (haltn == 1'b0)) ? 
                        s0__time_slices
                     : ((slice_cnt == 2'b00) & (clk == 1'b0)) ? 
                        s1__time_slices
                     : ((slice_cnt == 2'b01) & (clk == 1'b1)) ? 
                        s2__time_slices
                     : ((slice_cnt == 2'b01) & (clk == 1'b0)) ? 
                        s3__time_slices
                     : ((slice_cnt == 2'b10) & (clk == 1'b1)) ? 
                        s4__time_slices
                     : (((waitstates == 1'b1) & (slice_cnt == 2'b10)) & (clk == 1'b0)) ? 
                        s4__time_slices
                     : (((waitstates == 1'b0) & (slice_cnt == 2'b10)) & (clk == 1'b0)) ? 
                        s5__time_slices
                     : ((slice_cnt == 2'b11) & (clk == 1'b1)) ? 
                        s6__time_slices
                     :  s7__time_slices;
   
   always begin
       begin 
           @(negedge clk );
           case (t_slice)
               s4__time_slices : 
                       uds_wr_en_n <= 1'b1;
               default : 
                       uds_wr_en_n <= 1'b0;
           endcase
           case (t_slice)
               s4__time_slices : 
                       lds_wr_en_n <= 1'b1;
               default : 
                       lds_wr_en_n <= 1'b0;
           endcase
           case (t_slice)
               s2__time_slices,s4__time_slices : 
                       uds_rd_en_n <= 1'b1;
               default : 
                       uds_rd_en_n <= 1'b0;
           endcase
           case (t_slice)
               s2__time_slices,s4__time_slices : 
                       lds_rd_en_n <= 1'b1;
               default : 
                       lds_rd_en_n <= 1'b0;
           endcase
           case (t_slice)
               s2__time_slices,s4__time_slices : 
                       as_enab_n <= 1'b1;
               default : 
                       as_enab_n <= 1'b0;
           endcase
           case (t_slice)
               s2__time_slices : 
                       data_en_n <= 1'b1;
               default : 
                       data_en_n <= 1'b0;
           endcase
           if (((((t_slice == s0__time_slices) & ((rd_bus == 1'b1) | (wr_bus == 1'b1))) & (haltn == 1'b1)) & (arb_state == idle__arb_states))) 
                   adr_en_n <= 1'b1;
           else 
                   adr_en_n <= 1'b0;

           
       end
    end
   
   always begin
       begin 
           @(posedge clk );
           case (t_slice)
               s1__time_slices,s3__time_slices : 
                       as_enab_p <= 1'b1;
               default : 
                       as_enab_p <= 1'b0;
           endcase
           case (t_slice)
               s3__time_slices,s4__time_slices : 
                       uds_wr_en_p <= 1'b1;
               default : 
                       uds_wr_en_p <= 1'b0;
           endcase
           case (t_slice)
               s3__time_slices,s4__time_slices : 
                       lds_wr_en_p <= 1'b1;
               default : 
                       lds_wr_en_p <= 1'b0;
           endcase
           case (t_slice)
               s1__time_slices,s3__time_slices : 
                       uds_rd_en_p <= 1'b1;
               default : 
                       uds_rd_en_p <= 1'b0;
           endcase
           case (t_slice)
               s1__time_slices,s3__time_slices : 
                       lds_rd_en_p <= 1'b1;
               default : 
                       lds_rd_en_p <= 1'b0;
           endcase
           case (t_slice)
               s1__time_slices,s3__time_slices,s4__time_slices,s5__time_slices : 
                       wr_enab_p <= 1'b1;
               default : 
                       wr_enab_p <= 1'b0;
           endcase
           case (t_slice)
               s3__time_slices,s4__time_slices,s5__time_slices : 
                       data_en_p <= 1'b1;
               default : 
                       data_en_p <= 1'b0;
           endcase
           case (t_slice)
               s1__time_slices,s3__time_slices,s4__time_slices,s5__time_slices : 
                       adr_en_p <= 1'b1;
               default : 
                       adr_en_p <= 1'b0;
           endcase
       end
    end
   
   always begin
       begin 
           @(posedge clk );
           if ((resetn == 1'b0)) 
               begin 
                   e_timer__tmp = 4'h0;
                   vma_in <= 1'b1;
                   syncn <= 1'b1;
                   e <= 1'b1;
               end
           else if ((e_timer__tmp < 4'h9)) 
                   e_timer__tmp = (e_timer__tmp + 1'b1);
           else 
                   e_timer__tmp = 4'h0;

           if ((e_timer__tmp == 4'h0)) 
                   e <= 1'b1;
           else if ((e_timer__tmp == 4'h4)) 
                   e <= 1'b0;

           if (((vpan == 1'b0) & (e_timer__tmp >= 4'h4))) 
                   vma_in <= 1'b0;
           else if ((vpan == 1'b1)) 
                   vma_in <= 1'b1;

           if ((((vpan == 1'b0) & (vma_in == 1'b0)) & (e_timer__tmp == 4'h2))) 
                   syncn <= 1'b0;
           else if ((vpan == 1'b1)) 
                   syncn <= 1'b1;

           
       end
    end
   
       
   always @ (negedge resetn or negedge clk ) // begin 
           if ((resetn == 1'b0)) 
               arb_state <= idle__arb_states;
               
           else 
               arb_state <= next_arb_state;
               
           
   // end always 
   
       
   always @ (arb_state or tas_lock or brn or rd_bus or wr_bus or slice_cnt or bgackn ) // begin 
           case (arb_state)
               idle__arb_states : 
                       if ((tas_lock == 1'b1)) 
                               next_arb_state <= idle__arb_states;
                       else if (((brn == 1'b0) & (slice_cnt == 2'b00))) 
                               next_arb_state <= grant__arb_states;
                       else 
                               next_arb_state <= idle__arb_states;

                       
               grant__arb_states : 
                       if ((bgackn == 1'b0)) 
                               next_arb_state <= wait_release_3wire__arb_states;
                       else if ((brn == 1'b1)) 
                               next_arb_state <= idle__arb_states;
                       else 
                               next_arb_state <= grant__arb_states;

                       
               wait_release_3wire__arb_states : 
                       if (((bgackn == 1'b1) & (brn == 1'b0))) 
                               next_arb_state <= grant__arb_states;
                       else if ((bgackn == 1'b1)) 
                               next_arb_state <= idle__arb_states;
                       else 
                               next_arb_state <= wait_release_3wire__arb_states;

                       
           endcase
   // end always 
   
       
   always @ (negedge resetn or posedge clk ) // begin 
           if ((resetn == 1'b0)) 
               begin 
                   reset_filter__tmp = 4'hF;
                   reset_cpu_in <= 1'b0;
               end
               
           else 
               
                   begin 
                       if (((((reset_inn == 1'b0) & (haltn == 1'b0)) & (reset_out_en_i == 1'b0)) & (reset_filter__tmp < 4'hF))) 
                           reset_filter__tmp = (reset_filter__tmp + 1'b1);
                           
                       else if ((((reset_inn == 1'b1) | (haltn == 1'b1)) | (reset_out_en_i == 1'b1))) 
                           reset_filter__tmp = 4'h0;
                           
                       
                       if ((reset_filter__tmp > 4'hA)) 
                           reset_cpu_in <= 1'b0;
                           
                       else 
                           reset_cpu_in <= 1'b1;
                           
                       
                       
                   end
                   
               
           
   // end always 
   
       
   always @ (negedge resetn or posedge clk ) // begin 
           if ((resetn == 1'b0)) 
               begin 
                   reset_timer__tmp = {(6-0+1- 0){1'b0}};
                   reset_timer__lock = 1'b0;
               end
               
           else 
               
                   begin 
                       if (((reset_en == 1'b1) & (reset_timer__lock == 1'b0))) 
                           begin 
                               reset_timer__tmp = 7'b1111100;
                               reset_timer__lock = 1'b1;
                           end
                           
                       else if ((reset_timer__tmp > 7'b0000000)) 
                           reset_timer__tmp = (reset_timer__tmp - 1'b1);
                           
                       else if ((reset_en == 1'b0)) 
                           reset_timer__lock = 1'b0;
                           
                       
                       if ((reset_timer__tmp == 7'b0000001)) 
                           begin 
                               reset_out_en_i <= 1'b0;
                               reset_rdy <= 1'b1;
                           end
                           
                       else if ((reset_timer__tmp <= 7'b0000011)) 
                           begin 
                               reset_out_en_i <= 1'b0;
                               reset_rdy <= 1'b0;
                           end
                           
                       else 
                           begin 
                               reset_out_en_i <= 1'b1;
                               reset_rdy <= 1'b0;
                           end
                           
                       
                       
                   end
                   
               
           
   // end always 
   
   assign {reset_out_en}=reset_out_en_i;
   
   assign {reset_cpun}=reset_cpu_in;
    

endmodule
//--------------------------------------------------------------------
//--                                                              ----
//-- MC68000 compatible IP Core					                  ----
//--                                                              ----
//-- This file is part of the SUSKA ATARI clone project.          ----
//-- http://www.experiment-s.de                                   ----
//--                                                              ----
//-- Description:                                                 ----
//-- This model provides an opcode and bus timing compatible ip   ----
//-- core compared to Motorola's MC68000 microprocessor.          ----
//--                                                              ----
//-- This file is the package file of the ip core.                ----
//--                                                              ----
//--                                                              ----
//--                                                              ----
//--                                                              ----
//-- Author(s):                                                   ----
//-- - Wolfgang Foerster, wf@experiment-s.de; wf@inventronik.de   ----
//--                                                              ----
//-- Copyright (C) 2006 - 2011 Wolfgang Foerster                  ----
//--                                                              ----
//-- This source file is free software; you can redistribute it   ----
//-- and/or modify it under the terms of the GNU General Public   ----
//-- License as published by the Free Software Foundation; either ----
//-- version 2 of the License, or (at your option) any later      ----
//-- version.                                                     ----
//--                                                              ----
//-- This program is distributed in the hope that it will be      ----
//-- useful, but WITHOUT ANY WARRANTY; without even the implied   ----
//-- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ----
//-- PURPOSE.  See the GNU General Public License for more        ----
//-- details.                                                     ----
//--                                                              ----
//-- You should have received a copy of the GNU General Public    ----
//-- License along with this program; if not, write to the Free   ----
//-- Software Foundation, Inc., 51 Franklin Street, Fifth Floor,  ----
//-- Boston, MA 02110-1301, USA.                                  ----
//--                                                              ----
//--------------------------------------------------------------------
// 
// Revision History
// 
// Revision 2K6B  2006/12/24 WF
//   Initial Release.
// Revision 2K7A  2007/05/31 WF
//   Updated all modules.
// Revision 2K8A  2008/07/14 WF
//   See the 68K00 top level file.
// Revision 2K8B  2008/12/24 WF
//   See the 68K00 top level file.
// 

