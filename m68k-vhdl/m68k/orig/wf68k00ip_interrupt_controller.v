//-------------------------------------------------------------------
//
//   This file is automatically generated by VHDL to Verilog Translator.
//         Ver.1.24 thanks to T.I. Build May.8.2006
//               www.sugawara-systems.com   
//                    tech-support@sugawara-systems.com
//        See Original Copyright Notice for property of the file .( somewhere in this file.)
//
//--------------------------------------------------------------------


//--------------------------------------------------------------------
//--                                                              ----
//-- MC68000 compatible IP Core					                  ----
//--                                                              ----
//-- This file is part of the SUSKA ATARI clone project.          ----
//-- http://www.experiment-s.de                                   ----
//--                                                              ----
//-- Description:                                                 ----
//-- This model provides an opcode and bus timing compatible ip   ----
//-- core compared to Motorola's MC68000 microprocessor.          ----
//--                                                              ----
//-- This file contains the interrupt control unit.               ----
//--                                                              ----
//--                                                              ----
//-- Description:                                                 ----
//-- The interrupt control module is responsible for the inter-   ----
//-- rupt management of the external and internal interrupts and  ----
//-- for EXCEPTIONs processing. It manages auto-vectored inter-   ----
//-- rupt cycles, priority resolving and correct vector numbers   ----
//-- creation.                                                    ----
//-- There are different kinds of interrupt sources which require ----
//-- some special treatment: the RESET_CPU is released by exter-  ----
//-- nal logic. The exception state machine therefore has to      ----
//-- wait, once released, until this interrupt is released again. ----
//-- Interrupts, allowing the operation processing to finish the  ----
//-- current operation, have to wait for the CTRL_RDY signal.     ----
//-- The bus error exception starts the exception handler state   ----
//-- machine. In this case, there is no need to wait for the  bus ----
//-- error to withdrawn. It is assumed, that the bus error is     ----
//-- released by the bus interface logic during the exception     ----
//-- processing takes place. Double bus errors / address errors   ----
//-- cause the processor to enter the 'HALT' state.               ----
//--                                                              ----
//--                                                              ----
//-- Author(s):                                                   ----
//-- - Wolfgang Foerster, wf@experiment-s.de; wf@inventronik.de   ----
//--                                                              ----
//--------------------------------------------------------------------
//--                                                              ----
//-- Copyright (C) 2006 - 2013 Wolfgang Foerster                  ----
//--                                                              ----
//-- This source file is free software; you can redistribute it   ----
//-- and/or modify it under the terms of the GNU General Public   ----
//-- License as published by the Free Software Foundation; either ----
//-- version 2 of the License, or (at your option) any later      ----
//-- version.                                                     ----
//--                                                              ----
//-- This program is distributed in the hope that it will be      ----
//-- useful, but WITHOUT ANY WARRANTY; without even the implied   ----
//-- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ----
//-- PURPOSE.  See the GNU General Public License for more        ----
//-- details.                                                     ----
//--                                                              ----
//-- You should have received a copy of the GNU General Public    ----
//-- License along with this program; if not, write to the Free   ----
//-- Software Foundation, Inc., 51 Franklin Street, Fifth Floor,  ----
//-- Boston, MA 02110-1301, USA.                                  ----
//--                                                              ----
//--------------------------------------------------------------------
// 
// Revision History
// 
// Revision 2K6B  2006/12/24 WF
//   Initial Release.
// Revision 2K7A  2007/05/31 WF
//   Updated all modules.
// Revision 2K7B  2007/12/24 WF
//   See the 68K00 top level file.
// Revision 2K8A  2008/07/14 WF
//   See the 68K00 top level file.
// Revision 2K8B  2008/12/24 WF
//   Pending IPLn is now stored for processing, thanks to T. Gubener for the info.
// Revision 2K9A  2009/06/20 WF
//   Fixed a bug concerning the pending flags. They are now cleared during
//   execution of the reset exception.
// Revision 2K13B  20131224 WF
//   Changed the sequence for sampling the interrupt vector. It is now sampled before stacking.


module  wf68k00ip_interrupt_control ( clk, resetn, reset_cpun, berr, haltn, adr_in, use_ssp_adr, adr_en_vector, data_in, data_out, data_en, rwn, rd_bus, wr_bus, halt_en, fc_in, fc_out, fc_en, sel_buff_a_lo, sel_buff_a_hi, status_reg_in, pc, init_status, preset_irq_mask, ssp_dec, ssp_init, pc_init, biw_0, bus_cyc_rdy, ctrl_rdy, ctrl_en, exec_abort, exec_resume, irq_inn, irq_out, avecn, irq_save, int_vect, use_int_vect, trap_aerr, trap_op, trap_vector, trap_v, trap_chk, trap_divzero, trap_illegal, trap_1010, trap_1111, trap_trace, trap_priv );
    
    input  [0:0] clk;
    input  [0:0] resetn;
    input  [0:0] reset_cpun;
    input  [0:0] berr;
    input haltn;
    input [31:0]  adr_in ;
    output  [0:0] use_ssp_adr;
    output  [0:0] adr_en_vector;
    input [7:0]  data_in ;
    output [15:0]  data_out ;
    output  [0:0] data_en;
    input [0:0]  rwn ;
    output  [0:0] rd_bus;
    output  [0:0] wr_bus;
    output  [0:0] halt_en;
    input [2:0]  fc_in ;
    output [2:0]  fc_out ;
    output  [0:0] fc_en;
    output  [0:0] sel_buff_a_lo;
    output  [0:0] sel_buff_a_hi;
    input [15:0]  status_reg_in ;
    input [31:0]  pc ;
    output  [0:0] init_status;
    output  [0:0] preset_irq_mask;
    output  [0:0] ssp_dec;
    output  [0:0] ssp_init;
    output  [0:0] pc_init;
    input [15:0]  biw_0 ;
    input  [0:0] bus_cyc_rdy;
    input  [0:0] ctrl_rdy;
    output  [0:0] ctrl_en;
    output  [0:0] exec_abort;
    output  [0:0] exec_resume;
    input [2:0]  irq_inn ;
    output [2:0]  irq_out ;
    input  [0:0] avecn;
    output  [0:0] irq_save;
    output [9:0]  int_vect ;
    output  [0:0] use_int_vect;
    input  [0:0] trap_aerr;
    input  [0:0] trap_op;
    input [3:0]  trap_vector ;
    input  [0:0] trap_v;
    input  [0:0] trap_chk;
    input  [0:0] trap_divzero;
    input  [0:0] trap_illegal;
    input  [0:0] trap_1010;
    input  [0:0] trap_1111;
    input  [0:0] trap_trace;
    input  [0:0] trap_priv;


    reg [9:0] p_tmp_cpy__sr_mem;
    reg [7:0] int_vector__vector_no;
    reg [1:0] int_vector__vect_tmp;
//type ex_states
    parameter idle__ex_states=5'd0;
    parameter wait_ctrl_rdy__ex_states=5'd1;
    parameter init__ex_states=5'd2;
    parameter vect_nr__ex_states=5'd3;
    parameter get_vector__ex_states=5'd4;
    parameter stack_misc__ex_states=5'd5;
    parameter stack_access_adr_hi__ex_states=5'd6;
    parameter stack_access_adr_lo__ex_states=5'd7;
    parameter stack_instruction__ex_states=5'd8;
    parameter stack_status__ex_states=5'd9;
    parameter stack_pc_hi__ex_states=5'd10;
    parameter stack_pc_lo__ex_states=5'd11;
    parameter update_ssp_hi__ex_states=5'd12;
    parameter update_ssp_lo__ex_states=5'd13;
    parameter update_pc_hi__ex_states=5'd14;
    parameter update_pc_lo__ex_states=5'd15;
    parameter halt__ex_states=5'd16;
    
//type exceptions
    parameter ex_reset__exceptions=4'd0;
    parameter ex_bus_err__exceptions=4'd1;
    parameter ex_adr_err__exceptions=4'd2;
    parameter ex_illegal__exceptions=4'd3;
    parameter ex_divzero__exceptions=4'd4;
    parameter ex_chk__exceptions=4'd5;
    parameter ex_trapv__exceptions=4'd6;
    parameter ex_priv__exceptions=4'd7;
    parameter ex_trace__exceptions=4'd8;
    parameter ex_1010__exceptions=4'd9;
    parameter ex_1111__exceptions=4'd10;
    parameter ex_trap__exceptions=4'd11;
    parameter ex_int__exceptions=4'd12;
    parameter ex_none__exceptions=4'd13;
    
reg [4:0] ex_state;
reg [4:0] next_ex_state;
reg [3:0] exception_q;
reg [0:0] tmp_cpy =0; 
    reg [15:0] status_reg_tmp;
    reg [0:0] rwn_tmp;
    reg [2:0] fc_tmp;
    wire [2:0] irq_in;
    wire instrn;
    reg [31:0] adr_tmp;
reg [0:0] inc_tmp_vector =0; 
reg [0:0] ex_p_reset =0; 
reg [0:0] ex_p_adr_err =0; 
reg [0:0] ex_p_bus_err =0; 
reg [0:0] ex_p_trace =0; 
reg [0:0] ex_p_int =0; 
reg [0:0] ex_p_illegal =0; 
reg [0:0] ex_p_1010 =0; 
reg [0:0] ex_p_1111 =0; 
reg [0:0] ex_p_priv =0; 
reg [0:0] ex_p_trap =0; 
reg [0:0] ex_p_trapv =0; 
reg [0:0] ex_p_chk =0; 
reg [0:0] ex_p_divzero =0; 
wire [0:0] force_halt;
reg [0:0] preset_irq_mask_i =0; 
wire [0:0] use_ssp_adr;
wire [0:0] adr_en_vector;
    wire [15:0] data_out;
wire [0:0] data_en;
wire [0:0] rd_bus;
wire [0:0] wr_bus;
wire [0:0] halt_en;
    wire [2:0] fc_out;
wire [0:0] fc_en;
wire [0:0] sel_buff_a_lo;
wire [0:0] sel_buff_a_hi;
reg [0:0] init_status =0; 
wire [0:0] preset_irq_mask;
reg [0:0] ssp_dec =0; 
reg [0:0] ssp_init =0; 
reg [0:0] pc_init =0; 
wire [0:0] ctrl_en;
reg [0:0] exec_abort =0; 
wire [0:0] exec_resume;
    reg [2:0] irq_out;
reg [0:0] irq_save =0; 
    reg [9:0] int_vect;
reg [0:0] use_int_vect =0; 


    
   assign {halt_en}=(ex_state == halt__ex_states) ? 
                        1'b1
                     :  1'b0;
   
   assign {force_halt}=(((!(ex_state==idle__ex_states)) & ((berr == 1'b1) | (trap_aerr == 1'b1))) & (((exception_q == ex_reset__exceptions) | (exception_q == ex_adr_err__exceptions)) | (exception_q == ex_bus_err__exceptions))) ? 
                           1'b1
                        :  1'b0;
   
   assign {ctrl_en}=((((((((((((((ex_state == idle__ex_states) & (ex_p_reset == 1'b0)) & (ex_p_adr_err == 1'b0)) & (ex_p_bus_err == 1'b0)) & (ex_p_trace == 1'b0)) & (ex_p_int == 1'b0)) & (ex_p_illegal == 1'b0)) & (ex_p_1010 == 1'b0)) & (ex_p_1111 == 1'b0)) & (ex_p_priv == 1'b0)) & (ex_p_trap == 1'b0)) & (ex_p_trapv == 1'b0)) & (ex_p_chk == 1'b0)) & (ex_p_divzero == 1'b0)) ? 
                        1'b1
                     :  1'b0;
   
   assign instrn=exception_q==ex_reset__exceptions ? 1'b1 : 
           exception_q==ex_adr_err__exceptions ? 1'b1 : 
           exception_q==ex_bus_err__exceptions ? 1'b1 : 
           1'b0;
   
   assign {fc_out}=(ex_state == get_vector__ex_states) ? 
                       3'b111
                    : ((ex_state == update_ssp_hi__ex_states) | (ex_state == update_ssp_lo__ex_states)) ? 
                       3'b110
                    : ((ex_state == update_pc_hi__ex_states) | (ex_state == update_pc_lo__ex_states)) ? 
                       3'b110
                    :  3'b101;
   
   assign {fc_en}=(ex_state == idle__ex_states) ? 
                      1'b0
                   : (ex_state == wait_ctrl_rdy__ex_states) ? 
                      1'b0
                   : (ex_state == init__ex_states) ? 
                      1'b0
                   : (ex_state == vect_nr__ex_states) ? 
                      1'b0
                   :  1'b1;
   
   assign {use_ssp_adr}=(ex_state == stack_misc__ex_states) ? 
                            1'b1
                         : (ex_state == stack_access_adr_hi__ex_states) ? 
                            1'b1
                         : (ex_state == stack_access_adr_lo__ex_states) ? 
                            1'b1
                         : (ex_state == stack_instruction__ex_states) ? 
                            1'b1
                         : (ex_state == stack_status__ex_states) ? 
                            1'b1
                         : (ex_state == stack_pc_hi__ex_states) ? 
                            1'b1
                         : (ex_state == stack_pc_lo__ex_states) ? 
                            1'b1
                         :  1'b0;
   
   assign {sel_buff_a_lo}=(ex_state == update_ssp_lo__ex_states) ? 
                              1'b1
                           : (ex_state == update_pc_lo__ex_states) ? 
                              1'b1
                           :  1'b0;
   
   assign {sel_buff_a_hi}=(ex_state == update_ssp_hi__ex_states) ? 
                              1'b1
                           : (ex_state == update_pc_hi__ex_states) ? 
                              1'b1
                           :  1'b0;
   
   assign {adr_en_vector}=(ex_state == get_vector__ex_states) ? 
                              1'b1
                           :  1'b0;
   
   assign rd_bus=ex_state==get_vector__ex_states ? 1'b1 : 
           ex_state==update_ssp_hi__ex_states ? 1'b1 : 
           ex_state==update_ssp_lo__ex_states ? 1'b1 : 
           ex_state==update_pc_hi__ex_states ? 1'b1 : 
           ex_state==update_pc_lo__ex_states ? 1'b1 : 
           1'b0;
   
   assign wr_bus=ex_state==stack_misc__ex_states ? 1'b1 : 
           ex_state==stack_access_adr_hi__ex_states ? 1'b1 : 
           ex_state==stack_access_adr_lo__ex_states ? 1'b1 : 
           ex_state==stack_instruction__ex_states ? 1'b1 : 
           ex_state==stack_status__ex_states ? 1'b1 : 
           ex_state==stack_pc_hi__ex_states ? 1'b1 : 
           ex_state==stack_pc_lo__ex_states ? 1'b1 : 
           1'b0;
   
   assign {data_out}=(ex_state == stack_misc__ex_states) ? 
                         {{{11'b00000000000,rwn_tmp},instrn},fc_tmp}
                      : (ex_state == stack_access_adr_hi__ex_states) ? 
                         adr_tmp[31:16]
                      : (ex_state == stack_access_adr_lo__ex_states) ? 
                         adr_tmp[15:0]
                      : (ex_state == stack_instruction__ex_states) ? 
                         biw_0
                      : (ex_state == stack_status__ex_states) ? 
                         status_reg_tmp
                      : (ex_state == stack_pc_hi__ex_states) ? 
                         pc[31:16]
                      : (ex_state == stack_pc_lo__ex_states) ? 
                         pc[15:0]
                      :  {(15-0+1- 0){1'bx}};
   
   assign {data_en}=(ex_state == stack_misc__ex_states) ? 
                        1'b1
                     : (ex_state == stack_access_adr_hi__ex_states) ? 
                        1'b1
                     : (ex_state == stack_access_adr_lo__ex_states) ? 
                        1'b1
                     : (ex_state == stack_instruction__ex_states) ? 
                        1'b1
                     : (ex_state == stack_status__ex_states) ? 
                        1'b1
                     : (ex_state == stack_pc_hi__ex_states) ? 
                        1'b1
                     : (ex_state == stack_pc_lo__ex_states) ? 
                        1'b1
                     :  1'b0;
   
   assign {exec_resume}=(ex_p_int == 1'b1) ? 
                            1'b1
                         :  1'b0;
   
   assign {preset_irq_mask}=preset_irq_mask_i;
   
   assign {irq_in}=~ (irq_inn);
   
       
   always @ (negedge resetn or posedge clk ) // begin 
           if ((resetn == 1'b0)) 
               begin 
                   ex_p_reset <= 1'b0;
                   ex_p_adr_err <= 1'b0;
                   ex_p_bus_err <= 1'b0;
                   ex_p_trace <= 1'b0;
                   ex_p_int <= 1'b0;
                   ex_p_illegal <= 1'b0;
                   ex_p_1010 <= 1'b0;
                   ex_p_1111 <= 1'b0;
                   ex_p_priv <= 1'b0;
                   ex_p_trap <= 1'b0;
                   ex_p_trapv <= 1'b0;
                   ex_p_chk <= 1'b0;
                   ex_p_divzero <= 1'b0;
               end
               
           else 
               
                   begin 
                       if ((reset_cpun == 1'b0)) 
                           ex_p_reset <= 1'b1;
                           
                       else if ((((ex_state == update_pc_hi__ex_states) & (bus_cyc_rdy == 1'b1)) & (exception_q == ex_reset__exceptions))) 
                           ex_p_reset <= 1'b0;
                           
                       
                       if ((trap_aerr == 1'b1)) 
                           ex_p_adr_err <= 1'b1;
                           
                       else if ((((ex_state == update_pc_hi__ex_states) & (bus_cyc_rdy == 1'b1)) & (exception_q == ex_adr_err__exceptions))) 
                           ex_p_adr_err <= 1'b0;
                           
                       else if ((preset_irq_mask_i == 1'b1)) 
                           ex_p_adr_err <= 1'b0;
                           
                       
                       if ((((berr == 1'b1) & (haltn == 1'b1)) & (!(ex_state==get_vector__ex_states)))) 
                           ex_p_bus_err <= 1'b1;
                           
                       else if ((((ex_state == update_pc_hi__ex_states) & (bus_cyc_rdy == 1'b1)) & (exception_q == ex_bus_err__exceptions))) 
                           ex_p_bus_err <= 1'b0;
                           
                       else if ((preset_irq_mask_i == 1'b1)) 
                           ex_p_bus_err <= 1'b0;
                           
                       
                       if ((trap_trace == 1'b1)) 
                           ex_p_trace <= 1'b1;
                           
                       else if ((((ex_state == update_pc_hi__ex_states) & (bus_cyc_rdy == 1'b1)) & (exception_q == ex_trace__exceptions))) 
                           ex_p_trace <= 1'b0;
                           
                       else if ((preset_irq_mask_i == 1'b1)) 
                           ex_p_trace <= 1'b0;
                           
                       
                       if ((irq_in == 3'b111)) 
                           begin 
                               ex_p_int <= 1'b1;
                               irq_out <= irq_in;
                           end
                           
                       else if ((status_reg_in[10:8] < irq_in)) 
                           begin 
                               ex_p_int <= 1'b1;
                               irq_out <= irq_in;
                           end
                           
                       else if (((ex_state == get_vector__ex_states) & (bus_cyc_rdy == 1'b1))) 
                           ex_p_int <= 1'b0;
                           
                       else if ((preset_irq_mask_i == 1'b1)) 
                           ex_p_int <= 1'b0;
                           
                       
                       if ((trap_1010 == 1'b1)) 
                           ex_p_1010 <= 1'b1;
                           
                       else if ((trap_1111 == 1'b1)) 
                           ex_p_1111 <= 1'b1;
                           
                       else if ((trap_illegal == 1'b1)) 
                           ex_p_illegal <= 1'b1;
                           
                       else if ((trap_priv == 1'b1)) 
                           ex_p_priv <= 1'b1;
                           
                       else if ((trap_op == 1'b1)) 
                           ex_p_trap <= 1'b1;
                           
                       else if ((trap_v == 1'b1)) 
                           ex_p_trapv <= 1'b1;
                           
                       else if (((ex_state == update_pc_hi__ex_states) & (bus_cyc_rdy == 1'b1))) 
                           case (exception_q)
                               ex_priv__exceptions,ex_1010__exceptions,ex_1111__exceptions,ex_illegal__exceptions,ex_trap__exceptions,ex_trapv__exceptions : 
                                   begin 
                                       ex_p_priv <= 1'b0;
                                       ex_p_1010 <= 1'b0;
                                       ex_p_1111 <= 1'b0;
                                       ex_p_illegal <= 1'b0;
                                       ex_p_trap <= 1'b0;
                                       ex_p_trapv <= 1'b0;
                                   end
                               default : 
                                       ;//null
                           endcase
                           
                       else if ((preset_irq_mask_i == 1'b1)) 
                           begin 
                               ex_p_priv <= 1'b0;
                               ex_p_1010 <= 1'b0;
                               ex_p_1111 <= 1'b0;
                               ex_p_illegal <= 1'b0;
                               ex_p_trap <= 1'b0;
                               ex_p_trapv <= 1'b0;
                           end
                           
                       
                       if ((trap_chk == 1'b1)) 
                           ex_p_chk <= 1'b1;
                           
                       else if ((((ex_state == update_pc_hi__ex_states) & (bus_cyc_rdy == 1'b1)) & (exception_q == ex_chk__exceptions))) 
                           ex_p_chk <= 1'b0;
                           
                       else if ((preset_irq_mask_i == 1'b1)) 
                           ex_p_chk <= 1'b0;
                           
                       
                       if ((trap_divzero == 1'b1)) 
                           ex_p_divzero <= 1'b1;
                           
                       else if ((((ex_state == update_pc_hi__ex_states) & (bus_cyc_rdy == 1'b1)) & (exception_q == ex_divzero__exceptions))) 
                           ex_p_divzero <= 1'b0;
                           
                       else if ((preset_irq_mask_i == 1'b1)) 
                           ex_p_divzero <= 1'b0;
                           
                       
                       
                   end
                   
               
           
   // end always 
   
       
   always @ (negedge resetn or posedge clk ) // begin 
           if ((resetn == 1'b0)) 
               exception_q <= ex_none__exceptions;
               
           else 
               
                   if (((ex_state == idle__ex_states) & (ex_p_reset == 1'b1))) 
                       exception_q <= ex_reset__exceptions;
                       
                   else if (((ex_state == idle__ex_states) & (ex_p_adr_err == 1'b1))) 
                       exception_q <= ex_adr_err__exceptions;
                       
                   else if ((((ex_state == idle__ex_states) & (ex_p_bus_err == 1'b1)) & (berr == 1'b1))) 
                       exception_q <= ex_none__exceptions;
                       
                   else if (((ex_state == idle__ex_states) & (ex_p_bus_err == 1'b1))) 
                       exception_q <= ex_bus_err__exceptions;
                       
                   else if ((((ex_state == wait_ctrl_rdy__ex_states) & (ctrl_rdy == 1'b1)) & (ex_p_illegal == 1'b1))) 
                       exception_q <= ex_illegal__exceptions;
                       
                   else if ((((ex_state == wait_ctrl_rdy__ex_states) & (ctrl_rdy == 1'b1)) & (ex_p_1010 == 1'b1))) 
                       exception_q <= ex_1010__exceptions;
                       
                   else if ((((ex_state == wait_ctrl_rdy__ex_states) & (ctrl_rdy == 1'b1)) & (ex_p_1111 == 1'b1))) 
                       exception_q <= ex_1111__exceptions;
                       
                   else if ((((ex_state == wait_ctrl_rdy__ex_states) & (ctrl_rdy == 1'b1)) & (ex_p_priv == 1'b1))) 
                       exception_q <= ex_priv__exceptions;
                       
                   else if ((((ex_state == wait_ctrl_rdy__ex_states) & (ctrl_rdy == 1'b1)) & (ex_p_trap == 1'b1))) 
                       exception_q <= ex_trap__exceptions;
                       
                   else if ((((ex_state == wait_ctrl_rdy__ex_states) & (ctrl_rdy == 1'b1)) & (ex_p_trapv == 1'b1))) 
                       exception_q <= ex_trapv__exceptions;
                       
                   else if ((((ex_state == wait_ctrl_rdy__ex_states) & (ctrl_rdy == 1'b1)) & (ex_p_chk == 1'b1))) 
                       exception_q <= ex_chk__exceptions;
                       
                   else if ((((ex_state == wait_ctrl_rdy__ex_states) & (ctrl_rdy == 1'b1)) & (ex_p_divzero == 1'b1))) 
                       exception_q <= ex_divzero__exceptions;
                       
                   else if ((((ex_state == wait_ctrl_rdy__ex_states) & (ctrl_rdy == 1'b1)) & (ex_p_trace == 1'b1))) 
                       exception_q <= ex_trace__exceptions;
                       
                   else if ((((ex_state == wait_ctrl_rdy__ex_states) & (ctrl_rdy == 1'b1)) & (ex_p_int == 1'b1))) 
                       exception_q <= ex_int__exceptions;
                       
                   else if ((next_ex_state == idle__ex_states)) 
                       exception_q <= ex_none__exceptions;
                       
                   
                   
               
           
   // end always 
   
       
   always @ (posedge clk ) // begin 
       begin 
               
                   if ((tmp_cpy == 1'b1)) 
                       begin 
                           p_tmp_cpy__sr_mem = {{{status_reg_in[15],status_reg_in[13]},status_reg_in[10:8]},status_reg_in[4:0]};
                           rwn_tmp <= to_stdlogicvector__0(rwn);
                           fc_tmp <= fc_in;
                           adr_tmp <= adr_in;
                       end
                       
                   
                   
               
           status_reg_tmp <= {{{{{{p_tmp_cpy__sr_mem[9],1'b0},p_tmp_cpy__sr_mem[8]},2'b00},p_tmp_cpy__sr_mem[7:5]},3'b000},p_tmp_cpy__sr_mem[4:0]};
       end 
   // end always 
   
       
   always @ (negedge resetn or posedge clk ) // begin 
       begin 
           if ((resetn == 1'b0)) 
               int_vector__vector_no = {(7-0+1- 0){1'b0}};
               
           else 
               
                   if (((ex_state == vect_nr__ex_states) | (ex_state == get_vector__ex_states))) 
                       begin 
                           case (exception_q)
                               ex_reset__exceptions : 
                                       int_vector__vector_no = 8'h00;
                               ex_bus_err__exceptions : 
                                       int_vector__vector_no = 8'h02;
                               ex_adr_err__exceptions : 
                                       int_vector__vector_no = 8'h03;
                               ex_illegal__exceptions : 
                                       int_vector__vector_no = 8'h04;
                               ex_divzero__exceptions : 
                                       int_vector__vector_no = 8'h05;
                               ex_chk__exceptions : 
                                       int_vector__vector_no = 8'h06;
                               ex_trapv__exceptions : 
                                       int_vector__vector_no = 8'h07;
                               ex_priv__exceptions : 
                                       int_vector__vector_no = 8'h08;
                               ex_trace__exceptions : 
                                       int_vector__vector_no = 8'h09;
                               ex_1010__exceptions : 
                                       int_vector__vector_no = 8'h0A;
                               ex_1111__exceptions : 
                                       int_vector__vector_no = 8'h0B;
                               ex_int__exceptions : 
                                       if (((bus_cyc_rdy == 1'b1) & (berr == 1'b1))) 
                                               int_vector__vector_no = 8'h18;
                                       else if (((bus_cyc_rdy == 1'b1) & (avecn == 1'b0))) 
                                               int_vector__vector_no = (8'h18 + status_reg_in[10:8]);
                                       else if ((bus_cyc_rdy == 1'b1)) 
                                               int_vector__vector_no = data_in;

                                       
                               ex_trap__exceptions : 
                                       int_vector__vector_no = {4'h2,trap_vector};
                               default : 
                                       int_vector__vector_no = {(7-0+1- 0){1'bx}};
                           endcase
                           int_vector__vect_tmp = 2'b00;
                       end
                       
                   else if ((inc_tmp_vector == 1'b1)) 
                       int_vector__vect_tmp = (int_vector__vect_tmp + 1'b1);
                       
                   
                   
               
           int_vect <= ({int_vector__vector_no,2'b00} + {int_vector__vect_tmp,1'b0});
       end 
   // end always 
   
       
   always @ (negedge resetn or posedge clk ) // begin 
           if ((resetn == 1'b0)) 
               ex_state <= idle__ex_states;
               
           else 
               
                   if ((reset_cpun == 1'b0)) 
                       ex_state <= idle__ex_states;
                       
                   else if ((force_halt == 1'b1)) 
                       ex_state <= halt__ex_states;
                       
                   else 
                       ex_state <= next_ex_state;
                       
                   
                   
               
           
   // end always 
   
       
   always @ (ex_state or ex_p_reset or ex_p_adr_err or ex_p_bus_err or ex_p_trace or ex_p_int or ex_p_illegal or ex_p_1010 or ex_p_1111 or ex_p_priv or ex_p_trap or ex_p_trapv or ex_p_chk or ex_p_divzero or exception_q or bus_cyc_rdy or ctrl_rdy or berr ) // begin 
       begin 
           exec_abort <= 1'b0;
           tmp_cpy <= 1'b0;
           irq_save <= 1'b0;
           init_status <= 1'b0;
           preset_irq_mask_i <= 1'b0;
           ssp_init <= 1'b0;
           pc_init <= 1'b0;
           ssp_dec <= 1'b0;
           use_int_vect <= 1'b0;
           inc_tmp_vector <= 1'b0;
           case (ex_state)
               idle__ex_states : 
                       if ((ex_p_reset == 1'b1)) 
                           begin 
                               exec_abort <= 1'b1;
                               next_ex_state <= init__ex_states;
                           end
                       else if ((ex_p_adr_err == 1'b1)) 
                           begin 
                               exec_abort <= 1'b1;
                               tmp_cpy <= 1'b1;
                               next_ex_state <= init__ex_states;
                           end
                       else if (((ex_p_bus_err == 1'b1) & (berr == 1'b1))) 
                               next_ex_state <= idle__ex_states;
                       else if ((ex_p_bus_err == 1'b1)) 
                           begin 
                               exec_abort <= 1'b1;
                               tmp_cpy <= 1'b1;
                               next_ex_state <= init__ex_states;
                           end
                       else if ((((((ex_p_trap == 1'b1) | (ex_p_trapv == 1'b1)) | (ex_p_chk == 1'b1)) | (ex_p_divzero == 1'b1)) | (ex_p_trace == 1'b1))) 
                               next_ex_state <= wait_ctrl_rdy__ex_states;
                       else if ((((((ex_p_int == 1'b1) | (ex_p_illegal == 1'b1)) | (ex_p_1010 == 1'b1)) | (ex_p_1111 == 1'b1)) | (ex_p_priv == 1'b1))) 
                               next_ex_state <= wait_ctrl_rdy__ex_states;
                       else 
                               next_ex_state <= idle__ex_states;

                       
               wait_ctrl_rdy__ex_states : 
                       if ((ctrl_rdy == 1'b1)) 
                           begin 
                               tmp_cpy <= 1'b1;
                               next_ex_state <= init__ex_states;
                           end
                       else 
                               next_ex_state <= wait_ctrl_rdy__ex_states;

                       
               init__ex_states : 
                   begin 
                       init_status <= 1'b1;
                       case (exception_q)
                           ex_reset__exceptions : 
                               begin 
                                   preset_irq_mask_i <= 1'b1;
                                   next_ex_state <= vect_nr__ex_states;
                               end
                           ex_int__exceptions : 
                               begin 
                                   irq_save <= 1'b1;
                                   ssp_dec <= 1'b1;
                                   next_ex_state <= get_vector__ex_states;
                               end
                           default : 
                                   next_ex_state <= vect_nr__ex_states;
                       endcase
                   end
               vect_nr__ex_states : 
                       case (exception_q)
                           ex_reset__exceptions : 
                                   next_ex_state <= update_ssp_hi__ex_states;
                           default : 
                               begin 
                                   ssp_dec <= 1'b1;
                                   next_ex_state <= stack_pc_lo__ex_states;
                               end
                       endcase
               get_vector__ex_states : 
                       if ((bus_cyc_rdy == 1'b1)) 
                               next_ex_state <= stack_pc_lo__ex_states;
                       else 
                               next_ex_state <= get_vector__ex_states;

                       
               stack_pc_lo__ex_states : 
                       if ((bus_cyc_rdy == 1'b1)) 
                           begin 
                               ssp_dec <= 1'b1;
                               next_ex_state <= stack_pc_hi__ex_states;
                           end
                       else 
                               next_ex_state <= stack_pc_lo__ex_states;

                       
               stack_pc_hi__ex_states : 
                       if ((bus_cyc_rdy == 1'b1)) 
                           begin 
                               ssp_dec <= 1'b1;
                               next_ex_state <= stack_status__ex_states;
                           end
                       else 
                               next_ex_state <= stack_pc_hi__ex_states;

                       
               stack_status__ex_states : 
                       if ((bus_cyc_rdy == 1'b1)) 
                               case (exception_q)
                                   ex_bus_err__exceptions,ex_adr_err__exceptions : 
                                       begin 
                                           ssp_dec <= 1'b1;
                                           next_ex_state <= stack_instruction__ex_states;
                                       end
                                   default : 
                                           next_ex_state <= update_pc_hi__ex_states;
                               endcase
                       else 
                               next_ex_state <= stack_status__ex_states;

                       
               stack_instruction__ex_states : 
                       if ((bus_cyc_rdy == 1'b1)) 
                           begin 
                               ssp_dec <= 1'b1;
                               next_ex_state <= stack_access_adr_lo__ex_states;
                           end
                       else 
                               next_ex_state <= stack_instruction__ex_states;

                       
               stack_access_adr_lo__ex_states : 
                       if ((bus_cyc_rdy == 1'b1)) 
                           begin 
                               ssp_dec <= 1'b1;
                               next_ex_state <= stack_access_adr_hi__ex_states;
                           end
                       else 
                               next_ex_state <= stack_access_adr_lo__ex_states;

                       
               stack_access_adr_hi__ex_states : 
                       if ((bus_cyc_rdy == 1'b1)) 
                           begin 
                               ssp_dec <= 1'b1;
                               next_ex_state <= stack_misc__ex_states;
                           end
                       else 
                               next_ex_state <= stack_access_adr_hi__ex_states;

                       
               stack_misc__ex_states : 
                       if ((bus_cyc_rdy == 1'b1)) 
                               next_ex_state <= update_pc_hi__ex_states;
                       else 
                               next_ex_state <= stack_misc__ex_states;

                       
               update_ssp_hi__ex_states : 
                   begin 
                       if ((bus_cyc_rdy == 1'b1)) 
                           begin 
                               inc_tmp_vector <= 1'b1;
                               next_ex_state <= update_ssp_lo__ex_states;
                           end
                       else 
                               next_ex_state <= update_ssp_hi__ex_states;

                       use_int_vect <= 1'b1;
                   end
               update_ssp_lo__ex_states : 
                   begin 
                       if ((bus_cyc_rdy == 1'b1)) 
                           begin 
                               inc_tmp_vector <= 1'b1;
                               ssp_init <= 1'b1;
                               next_ex_state <= update_pc_hi__ex_states;
                           end
                       else 
                               next_ex_state <= update_ssp_lo__ex_states;

                       use_int_vect <= 1'b1;
                   end
               update_pc_hi__ex_states : 
                   begin 
                       if ((bus_cyc_rdy == 1'b1)) 
                           begin 
                               inc_tmp_vector <= 1'b1;
                               next_ex_state <= update_pc_lo__ex_states;
                           end
                       else 
                               next_ex_state <= update_pc_hi__ex_states;

                       use_int_vect <= 1'b1;
                   end
               update_pc_lo__ex_states : 
                   begin 
                       if ((bus_cyc_rdy == 1'b1)) 
                           begin 
                               pc_init <= 1'b1;
                               next_ex_state <= idle__ex_states;
                           end
                       else 
                               next_ex_state <= update_pc_lo__ex_states;

                       use_int_vect <= 1'b1;
                   end
               halt__ex_states : 
                       next_ex_state <= halt__ex_states;
           endcase
       end 
   // end always 
    
    function [((0-0+1) - 1):0] to_stdlogicvector__0;
        input  [0:0] b;
        reg [((0-0+1) - 1):0] result;
        begin : Function
            begin 
                begin :Block_Name_1
                    integer i;
                    for (i=((0-0+1) - 1);i>=0;i=i-1) begin 
                        case (b[0+(i-0)])
                            1'b0 : 
                                    result[i] = 1'b0;
                            1'b1 : 
                                    result[i] = 1'b1;
                        endcase
                        
                    end //for
                end //end Block
                begin 
                    to_stdlogicvector__0=result;
                    disable Function;
                end
            end
        end // Function
    endfunction
        

    

endmodule
//--------------------------------------------------------------------
//--                                                              ----
//-- MC68000 compatible IP Core					                  ----
//--                                                              ----
//-- This file is part of the SUSKA ATARI clone project.          ----
//-- http://www.experiment-s.de                                   ----
//--                                                              ----
//-- Description:                                                 ----
//-- This model provides an opcode and bus timing compatible ip   ----
//-- core compared to Motorola's MC68000 microprocessor.          ----
//--                                                              ----
//-- This file is the package file of the ip core.                ----
//--                                                              ----
//--                                                              ----
//--                                                              ----
//--                                                              ----
//-- Author(s):                                                   ----
//-- - Wolfgang Foerster, wf@experiment-s.de; wf@inventronik.de   ----
//--                                                              ----
//-- Copyright (C) 2006 - 2011 Wolfgang Foerster                  ----
//--                                                              ----
//-- This source file is free software; you can redistribute it   ----
//-- and/or modify it under the terms of the GNU General Public   ----
//-- License as published by the Free Software Foundation; either ----
//-- version 2 of the License, or (at your option) any later      ----
//-- version.                                                     ----
//--                                                              ----
//-- This program is distributed in the hope that it will be      ----
//-- useful, but WITHOUT ANY WARRANTY; without even the implied   ----
//-- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ----
//-- PURPOSE.  See the GNU General Public License for more        ----
//-- details.                                                     ----
//--                                                              ----
//-- You should have received a copy of the GNU General Public    ----
//-- License along with this program; if not, write to the Free   ----
//-- Software Foundation, Inc., 51 Franklin Street, Fifth Floor,  ----
//-- Boston, MA 02110-1301, USA.                                  ----
//--                                                              ----
//--------------------------------------------------------------------
// 
// Revision History
// 
// Revision 2K6B  2006/12/24 WF
//   Initial Release.
// Revision 2K7A  2007/05/31 WF
//   Updated all modules.
// Revision 2K8A  2008/07/14 WF
//   See the 68K00 top level file.
// Revision 2K8B  2008/12/24 WF
//   See the 68K00 top level file.
// 

