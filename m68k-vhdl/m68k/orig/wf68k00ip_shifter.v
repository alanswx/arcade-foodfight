//-------------------------------------------------------------------
//
//   This file is automatically generated by VHDL to Verilog Translator.
//         Ver.1.24 thanks to T.I. Build May.8.2006
//               www.sugawara-systems.com   
//                    tech-support@sugawara-systems.com
//        See Original Copyright Notice for property of the file .( somewhere in this file.)
//
//--------------------------------------------------------------------


//--------------------------------------------------------------------
//--                                                              ----
//-- MC68000 compatible IP Core					                  ----
//--                                                              ----
//-- This file is part of the SUSKA ATARI clone project.          ----
//-- http://www.experiment-s.de                                   ----
//--                                                              ----
//-- Description:                                                 ----
//-- This model provides an opcode and bus timing compatible ip   ----
//-- core compared to Motorola's MC68000 microprocessor.          ----
//--                                                              ----
//-- This file contains the 68Ks shifter unit.                    ----
//--                                                              ----
//--                                                              ----
//-- Description:                                                 ----
//-- This module performs the shifting operations ASL, ASR, LSL,  ----
//-- LSR, ROL, ROR, ROXL and ROXR as also the bit manipulation    ----
//-- and test operations BCHG, BCLR, BSET and BTST.               ----
//-- The timing of the core is as follows:                        ----
//-- All bit manipulation operations are performed by concurrent  ----
//-- statement modelling which results in immediate bit process-  ----
//-- ing. Thus, the result is valid one clock cycle after the     ----
//-- settings for the operands are stable.
//-- The shift and rotate operations start with SHIFTER_LOAD.     ----
//-- The data processing time is depending on the selected number ----
//-- of bits and is indicated by the SHFT_BUSY flag. During       ----
//-- SHFT_BUSY is asserted, the data calculation is in progress.  ----
//-- The execution time for these operations is n clock           ----
//-- cycles +2 where n is the desired number of shifts or rotates.----
//--                                                              ----
//--                                                              ----
//-- Author(s):                                                   ----
//-- - Wolfgang Foerster, wf@experiment-s.de; wf@inventronik.de   ----
//--                                                              ----
//--------------------------------------------------------------------
//--                                                              ----
//-- Copyright (C) 2006 - 2011 Wolfgang Foerster                  ----
//--                                                              ----
//-- This source file is free software; you can redistribute it   ----
//-- and/or modify it under the terms of the GNU General Public   ----
//-- License as published by the Free Software Foundation; either ----
//-- version 2 of the License, or (at your option) any later      ----
//-- version.                                                     ----
//--                                                              ----
//-- This program is distributed in the hope that it will be      ----
//-- useful, but WITHOUT ANY WARRANTY; without even the implied   ----
//-- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ----
//-- PURPOSE.  See the GNU General Public License for more        ----
//-- details.                                                     ----
//--                                                              ----
//-- You should have received a copy of the GNU General Public    ----
//-- License along with this program; if not, write to the Free   ----
//-- Software Foundation, Inc., 51 Franklin Street, Fifth Floor,  ----
//-- Boston, MA 02110-1301, USA.                                  ----
//--                                                              ----
//--------------------------------------------------------------------
// 
// Revision History
// 
// Revision 2K6B  2006/12/24 WF
//   Initial Release.
// Revision 2K7A  2007/05/31 WF
//   Updated all modules.
// Revision 2K7B  2007/12/24 WF
//   See the 68K00 top level file.
// Revision 2K8A  2008/07/14 WF
//   See the 68K00 top level file.
// Revision 2K11A  2011/06/20 WF
//   Cleaned up the condition code logic.
//   Removed the signal SHFT_BREAK from logic and entity.
// 


module  wf68k00ip_shifter ( clk, resetn, data_in, data_out, op, op_size, bit_pos, cnt_nr, shifter_load, shft_busy, xnzvc_in, xnzvc_out );
    //type op_sizetype
     parameter long__op_sizetype=2'd0;
     parameter word__op_sizetype=2'd1;
     parameter byte__op_sizetype=2'd2;
     
//type d_sizetype
     parameter long__d_sizetype=2'd0;
     parameter word__d_sizetype=2'd1;
     parameter byte__d_sizetype=2'd2;
     
//type op_68k00
     parameter abcd__op_68k00=7'd0;
     parameter add__op_68k00=7'd1;
     parameter adda__op_68k00=7'd2;
     parameter addi__op_68k00=7'd3;
     parameter addq__op_68k00=7'd4;
     parameter addx__op_68k00=7'd5;
     parameter and_b__op_68k00=7'd6;
     parameter andi__op_68k00=7'd7;
     parameter andi_to_ccr__op_68k00=7'd8;
     parameter andi_to_sr__op_68k00=7'd9;
     parameter asl__op_68k00=7'd10;
     parameter asr__op_68k00=7'd11;
     parameter bcc__op_68k00=7'd12;
     parameter bchg__op_68k00=7'd13;
     parameter bclr__op_68k00=7'd14;
     parameter bra__op_68k00=7'd15;
     parameter bset__op_68k00=7'd16;
     parameter bsr__op_68k00=7'd17;
     parameter btst__op_68k00=7'd18;
     parameter chk__op_68k00=7'd19;
     parameter clr__op_68k00=7'd20;
     parameter cmp__op_68k00=7'd21;
     parameter cmpa__op_68k00=7'd22;
     parameter cmpi__op_68k00=7'd23;
     parameter cmpm__op_68k00=7'd24;
     parameter dbcc__op_68k00=7'd25;
     parameter divs__op_68k00=7'd26;
     parameter divu__op_68k00=7'd27;
     parameter eor__op_68k00=7'd28;
     parameter eori__op_68k00=7'd29;
     parameter eori_to_ccr__op_68k00=7'd30;
     parameter eori_to_sr__op_68k00=7'd31;
     parameter exg__op_68k00=7'd32;
     parameter extw__op_68k00=7'd33;
     parameter illegal__op_68k00=7'd34;
     parameter jmp__op_68k00=7'd35;
     parameter jsr__op_68k00=7'd36;
     parameter lea__op_68k00=7'd37;
     parameter link__op_68k00=7'd38;
     parameter lsl__op_68k00=7'd39;
     parameter lsr__op_68k00=7'd40;
     parameter move__op_68k00=7'd41;
     parameter movea__op_68k00=7'd42;
     parameter move_from_ccr__op_68k00=7'd43;
     parameter move_to_ccr__op_68k00=7'd44;
     parameter move_from_sr__op_68k00=7'd45;
     parameter move_to_sr__op_68k00=7'd46;
     parameter move_usp__op_68k00=7'd47;
     parameter movem__op_68k00=7'd48;
     parameter movep__op_68k00=7'd49;
     parameter moveq__op_68k00=7'd50;
     parameter muls__op_68k00=7'd51;
     parameter mulu__op_68k00=7'd52;
     parameter nbcd__op_68k00=7'd53;
     parameter neg__op_68k00=7'd54;
     parameter negx__op_68k00=7'd55;
     parameter nop__op_68k00=7'd56;
     parameter not_b__op_68k00=7'd57;
     parameter or_b__op_68k00=7'd58;
     parameter ori__op_68k00=7'd59;
     parameter ori_to_ccr__op_68k00=7'd60;
     parameter ori_to_sr__op_68k00=7'd61;
     parameter pea__op_68k00=7'd62;
     parameter reset__op_68k00=7'd63;
     parameter rotl__op_68k00=7'd64;
     parameter rotr__op_68k00=7'd65;
     parameter roxl__op_68k00=7'd66;
     parameter roxr__op_68k00=7'd67;
     parameter rte__op_68k00=7'd68;
     parameter rtr__op_68k00=7'd69;
     parameter rts__op_68k00=7'd70;
     parameter sbcd__op_68k00=7'd71;
     parameter scc__op_68k00=7'd72;
     parameter stop__op_68k00=7'd73;
     parameter sub__op_68k00=7'd74;
     parameter suba__op_68k00=7'd75;
     parameter subi__op_68k00=7'd76;
     parameter subq__op_68k00=7'd77;
     parameter subx__op_68k00=7'd78;
     parameter swap__op_68k00=7'd79;
     parameter tas__op_68k00=7'd80;
     parameter trap__op_68k00=7'd81;
     parameter trapv__op_68k00=7'd82;
     parameter tst__op_68k00=7'd83;
     parameter unlk__op_68k00=7'd84;
     parameter reserved__op_68k00=7'd85;
     parameter unimplemented__op_68k00=7'd86;
     

    input  [0:0] clk;
    input  [0:0] resetn;
    input [31:0]  data_in ;
    output [31:0]  data_out ;
    input  [6:0] op;
    input  [1:0] op_size;
    input [4:0]  bit_pos ;
    input [5:0]  cnt_nr ;
    input  [0:0] shifter_load;
    output  [0:0] shft_busy;
    input [4:0]  xnzvc_in ;
    output [4:0]  xnzvc_out ;


    reg [4:0] /* integer transformed. */ bit_proc__bit_position;
    reg [5:0] p_shft_ctrl__bit_cnt;
    reg [4:0] /* integer transformed. */ cond_codes__bit_position;
    reg cond_codes__n_flag;
    reg cond_codes__z_flag;
    reg cond_codes__v_flag;
    reg cond_codes__c_flag;
//type shift_states
    parameter idle__shift_states=1'd0;
    parameter run__shift_states=1'd1;
    
reg [0:0] shift_state;
    reg [31:0] bit_op;
    reg [31:0] shft_op;
reg [0:0] shft_en =0; 
    reg x_flag;
    wire [31:0] data_out;
reg [0:0] shft_busy =0; 
    reg [4:0] xnzvc_out;


    
   assign data_out=op==bchg__op_68k00 ? bit_op : 
           op==bclr__op_68k00 ? bit_op : 
           op==bset__op_68k00 ? bit_op : 
           op==btst__op_68k00 ? bit_op : 
           shft_op;
   
       
   always @ (bit_pos or op or data_in ) // begin 
       begin 
           bit_proc__bit_position = bit_pos;
           bit_op <= data_in;
           case (op)
               bchg__op_68k00 : 
                       bit_op[bit_proc__bit_position] <= ~ (data_in[bit_proc__bit_position]);
               bclr__op_68k00 : 
                       bit_op[bit_proc__bit_position] <= 1'b0;
               bset__op_68k00 : 
                       bit_op[bit_proc__bit_position] <= 1'b1;
               default : 
                       bit_op <= data_in;
           endcase
       end 
   // end always 
   
       
   always @ (negedge resetn or posedge clk ) // begin 
           if ((resetn == 1'b0)) 
               shft_op <= {(31-0+1- 0){1'b0}};
               
           else 
               
                   if ((shifter_load == 1'b1)) 
                       shft_op <= data_in;
                       
                   else if ((shft_en == 1'b1)) 
                       case (op)
                           asl__op_68k00 : 
                                   if ((op_size == long__op_sizetype)) 
                                           shft_op <= {shft_op[30:0],1'b0};
                                   else if ((op_size == word__op_sizetype)) 
                                           shft_op <= {{16'h0000,shft_op[14:0]},1'b0};
                                   else 
                                           shft_op <= {{24'h000000,shft_op[6:0]},1'b0};

                                   
                           asr__op_68k00 : 
                                   if ((op_size == long__op_sizetype)) 
                                           shft_op <= {shft_op[31],shft_op[31:1]};
                                   else if ((op_size == word__op_sizetype)) 
                                           shft_op <= {{16'h0000,shft_op[15]},shft_op[15:1]};
                                   else 
                                           shft_op <= {{24'h000000,shft_op[7]},shft_op[7:1]};

                                   
                           lsl__op_68k00 : 
                                   if ((op_size == long__op_sizetype)) 
                                           shft_op <= {shft_op[30:0],1'b0};
                                   else if ((op_size == word__op_sizetype)) 
                                           shft_op <= {{16'h0000,shft_op[14:0]},1'b0};
                                   else 
                                           shft_op <= {{24'h000000,shft_op[6:0]},1'b0};

                                   
                           lsr__op_68k00 : 
                                   if ((op_size == long__op_sizetype)) 
                                           shft_op <= {1'b0,shft_op[31:1]};
                                   else if ((op_size == word__op_sizetype)) 
                                           shft_op <= {{1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0/*aggregate*/},shft_op[15:1]};
                                   else 
                                           shft_op <= {{1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0/*aggregate*/},shft_op[7:1]};

                                   
                           rotl__op_68k00 : 
                                   if ((op_size == long__op_sizetype)) 
                                           shft_op <= {shft_op[30:0],shft_op[31]};
                                   else if ((op_size == word__op_sizetype)) 
                                           shft_op <= {{16'h0000,shft_op[14:0]},shft_op[15]};
                                   else 
                                           shft_op <= {{24'h000000,shft_op[6:0]},shft_op[7]};

                                   
                           rotr__op_68k00 : 
                                   if ((op_size == long__op_sizetype)) 
                                           shft_op <= {shft_op[0],shft_op[31:1]};
                                   else if ((op_size == word__op_sizetype)) 
                                           shft_op <= {{16'h0000,shft_op[0]},shft_op[15:1]};
                                   else 
                                           shft_op <= {{24'h000000,shft_op[0]},shft_op[7:1]};

                                   
                           roxl__op_68k00 : 
                                   if ((op_size == long__op_sizetype)) 
                                           shft_op <= {shft_op[30:0],x_flag};
                                   else if ((op_size == word__op_sizetype)) 
                                           shft_op <= {{16'h0000,shft_op[14:0]},x_flag};
                                   else 
                                           shft_op <= {{24'h000000,shft_op[6:0]},x_flag};

                                   
                           roxr__op_68k00 : 
                                   if ((op_size == long__op_sizetype)) 
                                           shft_op <= {x_flag,shft_op[31:1]};
                                   else if ((op_size == word__op_sizetype)) 
                                           shft_op <= {{16'h0000,x_flag},shft_op[15:1]};
                                   else 
                                           shft_op <= {{24'h000000,x_flag},shft_op[7:1]};

                                   
                           default : 
                                   ;//null
                       endcase
                       
                   
                   
               
           
   // end always 
   
   always @ (negedge resetn or posedge clk ) begin 
       if ((resetn == 1'b0)) 
           begin 
               shift_state <= idle__shift_states;
               begin /* variable_assignment  p_shft_ctrl__bit_cnt  has moved. */ end 
               shft_en <= 1'b0;
               shft_busy <= 1'b0;
           end
           
       else 
           
               if ((shift_state == idle__shift_states)) 
                   begin 
                           if (((shifter_load == 1'b1) & (!(cnt_nr==6'b000000)))) 
                               begin 
                                   shift_state <= run__shift_states;
                                   p_shft_ctrl__bit_cnt = cnt_nr;
                                   shft_en <= 1'b1;
                                   shft_busy <= 1'b1;
                               end
                           else 
                               begin 
                                   shift_state <= idle__shift_states;
                                   p_shft_ctrl__bit_cnt = {(5-0+1- 0){1'b0}};
                                   shft_en <= 1'b0;
                                   shft_busy <= 1'b0;
                               end

                           
                   end 
               else if ((shift_state == run__shift_states)) 
                   begin 
                           if ((p_shft_ctrl__bit_cnt == 6'b000001)) 
                               begin 
                                   shift_state <= idle__shift_states;
                                   p_shft_ctrl__bit_cnt = cnt_nr;
                                   shft_en <= 1'b0;
                                   shft_busy <= 1'b0;
                               end
                           else 
                               begin 
                                   shift_state <= run__shift_states;
                                   p_shft_ctrl__bit_cnt = (p_shft_ctrl__bit_cnt - 1'b1);
                                   shft_en <= 1'b1;
                                   shft_busy <= 1'b1;
                               end

                           
                   end 
               
               
           
       
    end// always 
       
   always @ (resetn or clk or op ) // begin 
           if ((resetn == 1'b0)) 
               begin 
                   begin /* signal_assignment has moved. */ end 
                   p_shft_ctrl__bit_cnt = {(5-0+1- 0){1'b0}};
                   begin /* signal_assignment has moved. */ end 
                   begin /* signal_assignment has moved. */ end 
               end
               
           
   // end always 
   
   always @ (negedge resetn or posedge clk ) begin 
       if ((resetn == 1'b0)) 
           x_flag <= 1'b0;
           
       else 
           
               if (((shifter_load == 1'b1) | (cnt_nr == 6'b000000))) 
                   x_flag <= xnzvc_in[4];
                   
               else if ((shft_en == 1'b1)) 
                   case (op)
                       rotl__op_68k00,rotr__op_68k00 : 
                               x_flag <= xnzvc_in[4];
                       asl__op_68k00,lsl__op_68k00,roxl__op_68k00 : 
                               case (op_size)
                                   long__op_sizetype : 
                                           x_flag <= shft_op[31];
                                   word__op_sizetype : 
                                           x_flag <= shft_op[15];
                                   byte__op_sizetype : 
                                           x_flag <= shft_op[7];
                               endcase
                       default : 
                               x_flag <= shft_op[0];
                   endcase
                   
               
               
           
       
    end// always 
   always @ (negedge resetn or posedge clk ) begin 
       if ((resetn == 1'b0)) 
           begin /* variable_assignment  cond_codes__v_flag  has moved. */ end 
           
       else 
           
               if (((shifter_load == 1'b1) | (cnt_nr == 6'b000000))) 
                   cond_codes__v_flag = 1'b0;
                   
               else if ((shft_en == 1'b1)) 
                   case (op)
                       asl__op_68k00 : 
                               if ((op_size == long__op_sizetype)) 
                                       cond_codes__v_flag = ((shft_op[31] ^ shft_op[30]) | cond_codes__v_flag);
                               else if ((op_size == word__op_sizetype)) 
                                       cond_codes__v_flag = ((shft_op[15] ^ shft_op[14]) | cond_codes__v_flag);
                               else 
                                       cond_codes__v_flag = ((shft_op[7] ^ shft_op[6]) | cond_codes__v_flag);

                               
                       default : 
                               cond_codes__v_flag = 1'b0;
                   endcase
                   
               
               
           
       
    end// always 
   always @ (negedge resetn or posedge clk ) begin 
       if ((resetn == 1'b0)) 
           begin /* variable_assignment  cond_codes__c_flag  has moved. */ end 
           
       else 
           
               if ((((op == roxl__op_68k00) | (op == roxr__op_68k00)) & (cnt_nr == 6'b000000))) 
                   cond_codes__c_flag = xnzvc_in[4];
                   
               else if ((cnt_nr == 6'b000000)) 
                   cond_codes__c_flag = 1'b0;
                   
               else 
                   case (op)
                       asl__op_68k00,lsl__op_68k00,rotl__op_68k00,roxl__op_68k00 : 
                               case (op_size)
                                   long__op_sizetype : 
                                           cond_codes__c_flag = shft_op[31];
                                   word__op_sizetype : 
                                           cond_codes__c_flag = shft_op[15];
                                   byte__op_sizetype : 
                                           cond_codes__c_flag = shft_op[7];
                               endcase
                       default : 
                               cond_codes__c_flag = shft_op[0];
                   endcase
                   
               
               
           
       
    end// always 
       
   always @ (bit_pos or op or xnzvc_in or data_in or op_size or shft_op or x_flag or cnt_nr or resetn or clk ) // begin 
       begin 
           cond_codes__bit_position = bit_pos;
           case (op_size)
               long__op_sizetype : 
                       cond_codes__n_flag = shft_op[31];
               word__op_sizetype : 
                       cond_codes__n_flag = shft_op[15];
               default : 
                       cond_codes__n_flag = shft_op[7];
           endcase
           if (((op_size == long__op_sizetype) & (shft_op == 32'h00000000))) 
               cond_codes__z_flag = 1'b1;
               
           else if (((op_size == word__op_sizetype) & (shft_op[15:0] == 16'h0000))) 
               cond_codes__z_flag = 1'b1;
               
           else if (((op_size == byte__op_sizetype) & (shft_op[7:0] == 8'h00))) 
               cond_codes__z_flag = 1'b1;
               
           else 
               cond_codes__z_flag = 1'b0;
               
           if ((resetn == 1'b0)) 
               cond_codes__v_flag = 1'b0;
               
           if ((resetn == 1'b0)) 
               cond_codes__c_flag = 1'b0;
               
           case (op)
               bchg__op_68k00,bclr__op_68k00,bset__op_68k00,btst__op_68k00 : 
                       xnzvc_out <= {{xnzvc_in[4:3],~ (data_in[cond_codes__bit_position])},xnzvc_in[1:0]};
               default : 
                       xnzvc_out <= {{{{x_flag,cond_codes__n_flag},cond_codes__z_flag},cond_codes__v_flag},cond_codes__c_flag};
           endcase
       end 
   // end always 
    

endmodule
//--------------------------------------------------------------------
//--                                                              ----
//-- MC68000 compatible IP Core					                  ----
//--                                                              ----
//-- This file is part of the SUSKA ATARI clone project.          ----
//-- http://www.experiment-s.de                                   ----
//--                                                              ----
//-- Description:                                                 ----
//-- This model provides an opcode and bus timing compatible ip   ----
//-- core compared to Motorola's MC68000 microprocessor.          ----
//--                                                              ----
//-- This file is the package file of the ip core.                ----
//--                                                              ----
//--                                                              ----
//--                                                              ----
//--                                                              ----
//-- Author(s):                                                   ----
//-- - Wolfgang Foerster, wf@experiment-s.de; wf@inventronik.de   ----
//--                                                              ----
//-- Copyright (C) 2006 - 2011 Wolfgang Foerster                  ----
//--                                                              ----
//-- This source file is free software; you can redistribute it   ----
//-- and/or modify it under the terms of the GNU General Public   ----
//-- License as published by the Free Software Foundation; either ----
//-- version 2 of the License, or (at your option) any later      ----
//-- version.                                                     ----
//--                                                              ----
//-- This program is distributed in the hope that it will be      ----
//-- useful, but WITHOUT ANY WARRANTY; without even the implied   ----
//-- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ----
//-- PURPOSE.  See the GNU General Public License for more        ----
//-- details.                                                     ----
//--                                                              ----
//-- You should have received a copy of the GNU General Public    ----
//-- License along with this program; if not, write to the Free   ----
//-- Software Foundation, Inc., 51 Franklin Street, Fifth Floor,  ----
//-- Boston, MA 02110-1301, USA.                                  ----
//--                                                              ----
//--------------------------------------------------------------------
// 
// Revision History
// 
// Revision 2K6B  2006/12/24 WF
//   Initial Release.
// Revision 2K7A  2007/05/31 WF
//   Updated all modules.
// Revision 2K8A  2008/07/14 WF
//   See the 68K00 top level file.
// Revision 2K8B  2008/12/24 WF
//   See the 68K00 top level file.
// 

