//-------------------------------------------------------------------
//
//   This file is automatically generated by VHDL to Verilog Translator.
//         Ver.1.24 thanks to T.I. Build May.8.2006
//               www.sugawara-systems.com   
//                    tech-support@sugawara-systems.com
//        See Original Copyright Notice for property of the file .( somewhere in this file.)
//
//--------------------------------------------------------------------


//--------------------------------------------------------------------
//--                                                              ----
//-- MC68000 compatible IP Core					                  ----
//--                                                              ----
//-- This file is part of the SUSKA ATARI clone project.          ----
//-- http://www.experiment-s.de                                   ----
//--                                                              ----
//-- Description:                                                 ----
//-- This model provides an opcode and bus timing compatible ip   ----
//-- core compared to Motorola's MC68000 microprocessor.          ----
//--                                                              ----
//-- This file contains the 68Ks address registers.               ----
//--                                                              ----
//--                                                              ----
//-- Description:                                                 ----
//-- This file contains the 68K series data and address           ----
//-- registers, the user stack pointer (USP), the supervisor      ----
//-- stack pointer (SSP) and the 32-bit program counter (PC).     ----
//-- The required sign extensions for the INDEX and the DISPLACE- ----
//-- ment are provided by this model.                             ----
//--                                                              ----
//--                                                              ----
//-- Author(s):                                                   ----
//-- - Wolfgang Foerster, wf@experiment-s.de; wf@inventronik.de   ----
//--                                                              ----
//--------------------------------------------------------------------
//--                                                              ----
//-- Copyright (C) 2006 - 2011 Wolfgang Foerster                  ----
//--                                                              ----
//-- This source file is free software; you can redistribute it   ----
//-- and/or modify it under the terms of the GNU General Public   ----
//-- License as published by the Free Software Foundation; either ----
//-- version 2 of the License, or (at your option) any later      ----
//-- version.                                                     ----
//--                                                              ----
//-- This program is distributed in the hope that it will be      ----
//-- useful, but WITHOUT ANY WARRANTY; without even the implied   ----
//-- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ----
//-- PURPOSE.  See the GNU General Public License for more        ----
//-- details.                                                     ----
//--                                                              ----
//-- You should have received a copy of the GNU General Public    ----
//-- License along with this program; if not, write to the Free   ----
//-- Software Foundation, Inc., 51 Franklin Street, Fifth Floor,  ----
//-- Boston, MA 02110-1301, USA.                                  ----
//--                                                              ----
//--------------------------------------------------------------------
// 
// Revision History
// 
// Revision 2K6B  2006/12/24 WF
//   Initial Release.
// Revision 2K7A  2007/05/31 WF
//   Updated all modules.
// Revision 2K7B  2007/12/24 WF
//   See the 68K00 top level file.
// Revision 2K8A  2008/07/14 WF
//   See the 68K00 top level file.
// Revision 2K8B  2008/08/15 WF
//   Fixed the Ax,-(Ax) bug, thanks to T. Gubener for finding this out.
//   Fixed LINK A7 bug.
//   Fixed MOVEM (d8,ax,index) bug, thanks to T. Gubener for finding this out.
//   Fixed MOVE (Ax)+, Ax bug, thanks to T. Gubener for finding this out.
// 


module  wf68k00ip_address_registers ( clk, resetn, adata_in, regsel_b, regsel_a, adr_reg_qb, adr_reg_qa, usp_out, ssp_out, pc_out, exword, dest_exword, dr, usp_cpy, ar_exg, ar_wr, usp_inc, usp_dec, adr_tmp_clr, adr_tmp_inc, ar_inc, ar_dec, ssp_inc, ssp_dec, ssp_init, sp_add_displ, use_sp_adr, use_ssp_adr, pc_wr, pc_inc, pc_tmp_clr, pc_tmp_inc, pc_init, pc_add_displ, src_destn, sbit, op, op_size, op_mode, op_start, adr_mode, move_d_am, force_biw2, force_biw3, ext_dsize, sel_displace_biw, displace_biw, regsel_index, index_d_in, chk_pc, chk_adr, trap_aerr, adr_eff );
    //type op_sizetype
     parameter long__op_sizetype=2'd0;
     parameter word__op_sizetype=2'd1;
     parameter byte__op_sizetype=2'd2;
     
//type d_sizetype
     parameter long__d_sizetype=2'd0;
     parameter word__d_sizetype=2'd1;
     parameter byte__d_sizetype=2'd2;
     
//type op_68k00
     parameter abcd__op_68k00=7'd0;
     parameter add__op_68k00=7'd1;
     parameter adda__op_68k00=7'd2;
     parameter addi__op_68k00=7'd3;
     parameter addq__op_68k00=7'd4;
     parameter addx__op_68k00=7'd5;
     parameter and_b__op_68k00=7'd6;
     parameter andi__op_68k00=7'd7;
     parameter andi_to_ccr__op_68k00=7'd8;
     parameter andi_to_sr__op_68k00=7'd9;
     parameter asl__op_68k00=7'd10;
     parameter asr__op_68k00=7'd11;
     parameter bcc__op_68k00=7'd12;
     parameter bchg__op_68k00=7'd13;
     parameter bclr__op_68k00=7'd14;
     parameter bra__op_68k00=7'd15;
     parameter bset__op_68k00=7'd16;
     parameter bsr__op_68k00=7'd17;
     parameter btst__op_68k00=7'd18;
     parameter chk__op_68k00=7'd19;
     parameter clr__op_68k00=7'd20;
     parameter cmp__op_68k00=7'd21;
     parameter cmpa__op_68k00=7'd22;
     parameter cmpi__op_68k00=7'd23;
     parameter cmpm__op_68k00=7'd24;
     parameter dbcc__op_68k00=7'd25;
     parameter divs__op_68k00=7'd26;
     parameter divu__op_68k00=7'd27;
     parameter eor__op_68k00=7'd28;
     parameter eori__op_68k00=7'd29;
     parameter eori_to_ccr__op_68k00=7'd30;
     parameter eori_to_sr__op_68k00=7'd31;
     parameter exg__op_68k00=7'd32;
     parameter extw__op_68k00=7'd33;
     parameter illegal__op_68k00=7'd34;
     parameter jmp__op_68k00=7'd35;
     parameter jsr__op_68k00=7'd36;
     parameter lea__op_68k00=7'd37;
     parameter link__op_68k00=7'd38;
     parameter lsl__op_68k00=7'd39;
     parameter lsr__op_68k00=7'd40;
     parameter move__op_68k00=7'd41;
     parameter movea__op_68k00=7'd42;
     parameter move_from_ccr__op_68k00=7'd43;
     parameter move_to_ccr__op_68k00=7'd44;
     parameter move_from_sr__op_68k00=7'd45;
     parameter move_to_sr__op_68k00=7'd46;
     parameter move_usp__op_68k00=7'd47;
     parameter movem__op_68k00=7'd48;
     parameter movep__op_68k00=7'd49;
     parameter moveq__op_68k00=7'd50;
     parameter muls__op_68k00=7'd51;
     parameter mulu__op_68k00=7'd52;
     parameter nbcd__op_68k00=7'd53;
     parameter neg__op_68k00=7'd54;
     parameter negx__op_68k00=7'd55;
     parameter nop__op_68k00=7'd56;
     parameter not_b__op_68k00=7'd57;
     parameter or_b__op_68k00=7'd58;
     parameter ori__op_68k00=7'd59;
     parameter ori_to_ccr__op_68k00=7'd60;
     parameter ori_to_sr__op_68k00=7'd61;
     parameter pea__op_68k00=7'd62;
     parameter reset__op_68k00=7'd63;
     parameter rotl__op_68k00=7'd64;
     parameter rotr__op_68k00=7'd65;
     parameter roxl__op_68k00=7'd66;
     parameter roxr__op_68k00=7'd67;
     parameter rte__op_68k00=7'd68;
     parameter rtr__op_68k00=7'd69;
     parameter rts__op_68k00=7'd70;
     parameter sbcd__op_68k00=7'd71;
     parameter scc__op_68k00=7'd72;
     parameter stop__op_68k00=7'd73;
     parameter sub__op_68k00=7'd74;
     parameter suba__op_68k00=7'd75;
     parameter subi__op_68k00=7'd76;
     parameter subq__op_68k00=7'd77;
     parameter subx__op_68k00=7'd78;
     parameter swap__op_68k00=7'd79;
     parameter tas__op_68k00=7'd80;
     parameter trap__op_68k00=7'd81;
     parameter trapv__op_68k00=7'd82;
     parameter tst__op_68k00=7'd83;
     parameter unlk__op_68k00=7'd84;
     parameter reserved__op_68k00=7'd85;
     parameter unimplemented__op_68k00=7'd86;
     

    input  [0:0] clk;
    input  [0:0] resetn;
    input [31:0]  adata_in ;
    input [2:0]  regsel_b ;
    input [2:0]  regsel_a ;
    output [31:0]  adr_reg_qb ;
    output [31:0]  adr_reg_qa ;
    output [31:0]  usp_out ;
    output [31:0]  ssp_out ;
    output [31:0]  pc_out ;
    input [15:0]  exword  [0:1];
    input [15:0]  dest_exword  [0:1];
    input  [0:0] dr;
    input  [0:0] usp_cpy;
    input  [0:0] ar_exg;
    input  [0:0] ar_wr;
    input  [0:0] usp_inc;
    input  [0:0] usp_dec;
    input  [0:0] adr_tmp_clr;
    input  [0:0] adr_tmp_inc;
    input  [0:0] ar_inc;
    input  [0:0] ar_dec;
    input  [0:0] ssp_inc;
    input  [0:0] ssp_dec;
    input  [0:0] ssp_init;
    input  [0:0] sp_add_displ;
    input  [0:0] use_sp_adr;
    input  [0:0] use_ssp_adr;
    input  [0:0] pc_wr;
    input  [0:0] pc_inc;
    input  [0:0] pc_tmp_clr;
    input  [0:0] pc_tmp_inc;
    input  [0:0] pc_init;
    input  [0:0] pc_add_displ;
    input  [0:0] src_destn;
    input  [0:0] sbit;
    input  [6:0] op;
    input  [1:0] op_size;
    input [4:0]  op_mode ;
    input  [0:0] op_start;
    input [2:0]  adr_mode ;
    input [2:0]  move_d_am ;
    input  [0:0] force_biw2;
    input  [0:0] force_biw3;
    input  [1:0] ext_dsize;
    input  [0:0] sel_displace_biw;
    input [31:0]  displace_biw ;
    input [2:0]  regsel_index ;
    input [31:0]  index_d_in ;
    input  [0:0] chk_pc;
    input  [0:0] chk_adr;
    output  [0:0] trap_aerr;
    output [31:0]  adr_eff ;


    reg [31:0] extend_index__index_tmp;
    reg [31:0] extend_index__index_ext;
    reg [1:0] extend_index__iwl_ida=0;
    reg [3:0] p_pc_tmp__pc_tmpvar;
    reg [31:0] address_modes__adr_eff_tmp;
    reg [31:0] address_modes__areg;
    reg [31:0] ar [0:6];
    reg [31:0] data_signed;
    reg [31:0] usp;
    reg [31:0] ssp;
    reg [31:0] pc;
    reg [31:0] areg_tmp;
    wire [2:0] adr_mode_i;
    wire [31:0] displace;
    reg [31:0] displ_ext;
wire [0:0] i_d_a;
wire [0:0] i_w_l;
    wire [1:0] i_scale;
wire [0:0] index_sign;
    reg [31:0] index_scaled;
    wire [31:0] abs_address;
    wire [31:0] ar_nr_a;
    wire [31:0] ar_nr_b;
    wire [31:0] ar_nr_i;
    reg [31:0] adr_eff_i;
    reg [5:0] adr_tmp;
    reg [4:0] pc_tmp;
    wire [3:0] pc_offset;
    wire [2:0] ar_step;
    wire [31:0] adr_reg_qb;
    wire [31:0] adr_reg_qa;
    wire [31:0] usp_out;
    wire [31:0] ssp_out;
    wire [31:0] pc_out;
wire [0:0] trap_aerr;
    reg [31:0] adr_eff;


    
   assign {adr_mode_i}=((src_destn == 1'b0) & (op == move__op_68k00)) ? 
                           move_d_am
                        :  adr_mode;
   
   assign {ar_nr_a}=regsel_a;
   
   assign {ar_nr_b}=regsel_b;
   
   assign {ar_nr_i}=regsel_index;
   
   assign {trap_aerr}=((chk_pc == 1'b1) & (pc[0] == 1'b1)) ? 
                          1'b1
                       : (((chk_adr == 1'b1) & (use_ssp_adr == 1'b1)) & (ssp[0] == 1'b1)) ? 
                          1'b1
                       : ((((chk_adr == 1'b1) & (use_sp_adr == 1'b1)) & (sbit == 1'b1)) & (ssp[0] == 1'b1)) ? 
                          1'b1
                       : (((chk_adr == 1'b1) & (use_sp_adr == 1'b1)) & (usp[0] == 1'b1)) ? 
                          1'b1
                       : ((chk_adr == 1'b1) & ((use_ssp_adr == 1'b1) | (use_sp_adr == 1'b1))) ? 
                          1'b0
                       : ((((chk_adr == 1'b1) & (!(op==movep__op_68k00))) & (op_size == long__op_sizetype)) & (adr_eff_i[0] == 1'b1)) ? 
                          1'b1
                       : ((((chk_adr == 1'b1) & (!(op==movep__op_68k00))) & (op_size == word__op_sizetype)) & (adr_eff_i[0] == 1'b1)) ? 
                          1'b1
                       :  1'b0;
   
   assign {ar_step}=(op_size == long__op_sizetype) ? 
                        3'b100
                     : (op_size == word__op_sizetype) ? 
                        3'b010
                     : ((op_size == byte__op_sizetype) & (ar_nr_b == 7)) ? 
                        3'b010
                     :  3'b001;
   
   assign {usp_out}=usp;
   
   assign {ssp_out}=ssp;
   
   assign {pc_out}=(pc + pc_tmp);
   
   assign {adr_reg_qa}=(((op == movem__op_68k00) & (adr_mode_i == 3'b100)) & (regsel_a == regsel_b)) ? 
                           areg_tmp
                        : (((op == move__op_68k00) & (adr_mode == 3'b001)) & (move_d_am == 3'b100)) ? 
                           areg_tmp
                        : (op == pea__op_68k00) ? 
                           areg_tmp
                        : ((ar_nr_a == 7) & (sbit == 1'b1)) ? 
                           ssp
                        : ((ar_nr_a == 7) & (sbit == 1'b0)) ? 
                           usp
                        :  ar[ar_nr_a];
   
   assign {adr_reg_qb}=(op == link__op_68k00) ? 
                           areg_tmp
                        : ((ar_nr_b == 7) & (sbit == 1'b1)) ? 
                           ssp
                        : ((ar_nr_b == 7) & (sbit == 1'b0)) ? 
                           usp
                        :  ar[ar_nr_b];
   
       
   always @ (negedge resetn or posedge clk ) // begin 
           if ((resetn == 1'b0)) 
               areg_tmp <= 32'h00000000;
               
           else 
               
                   if ((((op == link__op_68k00) | (op == movem__op_68k00)) & (op_start == 1'b1))) 
                       case (ar_nr_b)
                           7 :     if ((sbit == 1'b1)) 
                                           areg_tmp <= ssp;
                                   else 
                                           areg_tmp <= usp;

                                   
                           default : 
                                   areg_tmp <= ar[ar_nr_b];
                       endcase
                       
                   else if (((op == move__op_68k00) & (op_start == 1'b1))) 
                       case (ar_nr_a)
                           7 :     if ((sbit == 1'b1)) 
                                           areg_tmp <= ssp;
                                   else 
                                           areg_tmp <= usp;

                                   
                           default : 
                                   areg_tmp <= ar[ar_nr_a];
                       endcase
                       
                   else if (((op == pea__op_68k00) & (op_start == 1'b1))) 
                       areg_tmp <= adr_eff_i;
                       
                   
                   
               
           
   // end always 
   
       
   always @ (op or op_size or adata_in or adr_eff_i ) // begin 
           if ((((op == movea__op_68k00) | (op == movem__op_68k00)) & (op_size == word__op_sizetype))) 
               begin 
                   begin :Block_Name_1
                       integer i;
                       for (i=31;i>=16;i=i-1) begin 
                           data_signed[i] <= adata_in[15];
                           
                       end //for
                   end //end Block
                   data_signed[15:0] <= adata_in[15:0];
               end
               
           else if ((((op == jmp__op_68k00) | (op == jsr__op_68k00)) | (op == lea__op_68k00))) 
               data_signed <= adr_eff_i;
               
           else 
               data_signed <= adata_in;
               
           
   // end always 
   
   assign {i_d_a}=((exword[0][15] == 1'b1) & (src_destn == 1'b1)) ? 
                      1'b1
                   : ((dest_exword[0][15] == 1'b1) & (src_destn == 1'b0)) ? 
                      1'b1
                   :  1'b0;
   
   assign {i_w_l}=((exword[0][11] == 1'b1) & (src_destn == 1'b1)) ? 
                      1'b1
                   : ((dest_exword[0][11] == 1'b1) & (src_destn == 1'b0)) ? 
                      1'b1
                   :  1'b0;
   
   assign {i_scale}=(src_destn == 1'b1) ? 
                        exword[0][10:9]
                     :  dest_exword[0][10:9];
   
   assign {abs_address}=(((adr_mode_i == 3'b111) & (regsel_b == 3'b000)) & (src_destn == 1'b1)) ? 
                            {16'h0000,exword[0]}
                         : (((adr_mode_i == 3'b111) & (regsel_b == 3'b000)) & (src_destn == 1'b0)) ? 
                            {16'h0000,dest_exword[0]}
                         : (src_destn == 1'b1) ? 
                            {exword[0],exword[1]}
                         :  {dest_exword[0],dest_exword[1]};
   
   always @ (posedge clk or negedge resetn ) begin 
       if ((resetn == 1'b0)) 
           begin /* variable_assignment  extend_index__index_tmp  has moved. */ end 
           
       else 
           
               if ((((op == movem__op_68k00) & (op_start == 1'b1)) & (i_d_a == 1'b1))) 
                   extend_index__index_tmp = ar[ar_nr_i];
                   
               else if (((op == movem__op_68k00) & (op_start == 1'b1))) 
                   extend_index__index_tmp = index_d_in;
                   
               
               
           
       
    end// always 
       
   always @ (clk or resetn or ar_nr_i or i_d_a or i_w_l or ar_W  or op or index_d_in or i_scale ) // begin 
       begin 
           extend_index__iwl_ida = {i_w_l,i_d_a};
           if ((resetn == 1'b0)) 
               extend_index__index_tmp = {(31-0+1- 0){1'b0}};
               
           case (op)
               movem__op_68k00 : 
                       case (i_w_l)
                           1'b0 : 
                               begin 
                                   begin :Block_Name_2
                                       integer i;
                                       for (i=31;i>=16;i=i-1) begin 
                                           extend_index__index_ext[i] = extend_index__index_tmp[15];
                                           
                                       end //for
                                   end //end Block
                                   extend_index__index_ext[15:0] = extend_index__index_tmp[15:0];
                               end
                           1'b1 : 
                                   extend_index__index_ext = extend_index__index_tmp;
                       endcase
               default : 
                       case (extend_index__iwl_ida)
                           2'b01 : 
                               begin 
                                   begin :Block_Name_3
                                       integer i;
                                       for (i=31;i>=16;i=i-1) begin 
                                           extend_index__index_ext[i] = ar[ar_nr_i][15];
                                           
                                       end //for
                                   end //end Block
                                   extend_index__index_ext[15:0] = ar[ar_nr_i][15:0];
                               end
                           2'b00 : 
                               begin 
                                   begin :Block_Name_4
                                       integer i;
                                       for (i=31;i>=16;i=i-1) begin 
                                           extend_index__index_ext[i] = index_d_in[15];
                                           
                                       end //for
                                   end //end Block
                                   extend_index__index_ext[15:0] = index_d_in[15:0];
                               end
                           2'b11 : 
                                   extend_index__index_ext = ar[ar_nr_i];
                           2'b10 : 
                                   extend_index__index_ext = index_d_in;
                       endcase
           endcase
           case (i_scale)
               2'b00 : 
                       index_scaled <= extend_index__index_ext;
               2'b01 : 
                       index_scaled <= {extend_index__index_ext[31:1],1'b0};
               2'b10 : 
                       index_scaled <= {extend_index__index_ext[31:2],2'b00};
               2'b11 : 
                       index_scaled <= {extend_index__index_ext[31:3],3'b000};
           endcase
       end 
   // end always 
   
   assign {displace}=(sel_displace_biw == 1'b1) ? 
                         displace_biw
                      : ((ext_dsize == word__d_sizetype) & (src_destn == 1'b1)) ? 
                         {16'h0000,exword[0]}
                      : ((ext_dsize == byte__d_sizetype) & (src_destn == 1'b1)) ? 
                         {24'h000000,exword[0][7:0]}
                      : (ext_dsize == word__d_sizetype) ? 
                         {16'h0000,dest_exword[0]}
                      :  {24'h000000,dest_exword[0][7:0]};
   
       
   always @ (displace or ext_dsize ) // begin 
           case (ext_dsize)
               byte__d_sizetype : 
                   begin 
                       begin :Block_Name_5
                           integer i;
                           for (i=31;i>=8;i=i-1) begin 
                               displ_ext[i] <= displace[7];
                               
                           end //for
                       end //end Block
                       displ_ext[7:0] <= displace[7:0];
                   end
               word__d_sizetype : 
                   begin 
                       begin :Block_Name_6
                           integer i;
                           for (i=31;i>=16;i=i-1) begin 
                               displ_ext[i] <= displace[15];
                               
                           end //for
                       end //end Block
                       displ_ext[15:0] <= displace[15:0];
                   end
               long__d_sizetype : 
                       displ_ext <= displace;
           endcase
   // end always 
   
       
   always @ (negedge resetn or posedge clk ) // begin 
           if ((resetn == 1'b0)) 
               adr_tmp <= 6'b000000;
               
           else 
               
                   if ((adr_tmp_clr == 1'b1)) 
                       adr_tmp <= 6'b000000;
                       
                   else if (((adr_tmp_inc == 1'b1) & (op_size == byte__op_sizetype))) 
                       adr_tmp <= (adr_tmp + 2'b01);
                       
                   else if ((adr_tmp_inc == 1'b1)) 
                       adr_tmp <= (adr_tmp + 2'b10);
                       
                   
                   
               
           
   // end always 
   
       
   always @ (negedge resetn or posedge clk ) // begin 
       begin 
           if ((resetn == 1'b0)) 
               p_pc_tmp__pc_tmpvar = 4'h0;
               
           else 
               
                   if (((pc_inc == 1'b1) | (pc_tmp_clr == 1'b1))) 
                       p_pc_tmp__pc_tmpvar = 4'h0;
                       
                   else if ((pc_tmp_inc == 1'b1)) 
                       p_pc_tmp__pc_tmpvar = (p_pc_tmp__pc_tmpvar + 1'b1);
                       
                   
                   
               
           pc_tmp <= {p_pc_tmp__pc_tmpvar,1'b0};
       end 
   // end always 
   
   assign {pc_offset}=((force_biw3 == 1'b1) & (force_biw2 == 1'b1)) ? 
                          4'h6
                       : (force_biw2 == 1'b1) ? 
                          4'h4
                       :  4'h2;
   
       
   always @ (adr_mode_i or regsel_b or ar_W  or ar_nr_b or sbit or usp or ssp or displ_ext or areg_tmp or adr_tmp or op or index_scaled or abs_address or pc or pc_offset or adr_eff_i or dr ) // begin 
       begin 
           if ((((op == movem__op_68k00) & (((adr_mode_i == 3'b010) | (adr_mode_i == 3'b101)) | (adr_mode_i == 3'b110))) & (dr == 1'b1))) 
               address_modes__areg = areg_tmp;
               
           else 
               case (ar_nr_b)
                   7 :     if ((sbit == 1'b1)) 
                                   address_modes__areg = ssp;
                           else 
                                   address_modes__areg = usp;

                           
                   default : 
                           address_modes__areg = ar[ar_nr_b];
               endcase
               
           case (adr_mode_i)
               3'b010,3'b011,3'b100 : 
                       address_modes__adr_eff_tmp = address_modes__areg;
               3'b101 : 
                       address_modes__adr_eff_tmp = (address_modes__areg + displ_ext);
               3'b110 : 
                       address_modes__adr_eff_tmp = ((address_modes__areg + displ_ext) + index_scaled);
               3'b111 : 
                       case (regsel_b)
                           3'b000 : 
                               begin 
                                   begin :Block_Name_7
                                       integer i;
                                       for (i=31;i>=16;i=i-1) begin 
                                           address_modes__adr_eff_tmp[i] = abs_address[15];
                                           
                                       end //for
                                   end //end Block
                                   address_modes__adr_eff_tmp[15:0] = abs_address[15:0];
                               end
                           3'b001 : 
                                   address_modes__adr_eff_tmp = abs_address;
                           3'b010 : 
                                   address_modes__adr_eff_tmp = ((pc + pc_offset) + displ_ext);
                           3'b011 : 
                                   address_modes__adr_eff_tmp = (((pc + pc_offset) + displ_ext) + index_scaled);
                           default : 
                                   address_modes__adr_eff_tmp = {(31-0+1- 0){1'bx}};
                       endcase
               default : 
                       address_modes__adr_eff_tmp = {(31-0+1- 0){1'bx}};
           endcase
           adr_eff_i <= address_modes__adr_eff_tmp;
           adr_eff <= (adr_eff_i + adr_tmp);
       end 
   // end always 
   
   always @ (negedge resetn or posedge clk ) begin 
       if ((resetn == 1'b0)) 
           begin 
               begin :Block_Name_8
                   integer i;
                   for (i=0;i<=6;i=i+1) begin 
                       ar[i] <= {(31-0+1- 0){1'b0}};
                       
                   end //for
               end //end Block
               usp <= {(31-0+1- 0){1'b0}};
               ssp <= {(31-0+1- 0){1'b0}};
               pc <= {(31-0+1- 0){1'b0}};
           end
           
       else 
           
               begin 
                   if (((ar_inc == 1'b1) & (ar_nr_b < 7))) 
                       ar[ar_nr_b] <= (ar[ar_nr_b] + ar_step);
                       
                   else if (((ar_inc == 1'b1) & (sbit == 1'b1))) 
                       ssp <= (ssp + ar_step);
                       
                   else if ((ar_inc == 1'b1)) 
                       usp <= (usp + ar_step);
                       
                   else if (((ar_dec == 1'b1) & (ar_nr_b < 7))) 
                       ar[ar_nr_b] <= (ar[ar_nr_b] - ar_step);
                       
                   else if (((ar_dec == 1'b1) & (sbit == 1'b1))) 
                       ssp <= (ssp - ar_step);
                       
                   else if ((ar_dec == 1'b1)) 
                       usp <= (usp - ar_step);
                       
                   
                   if ((ar_wr == 1'b1)) 
                       begin 
                               if ((ar_nr_a < 7)) 
                                       ar[ar_nr_a] <= data_signed;
                               else if ((sbit == 1'b1)) 
                                       ssp <= data_signed;
                               else 
                                       usp <= data_signed;

                               
                       end 
                   
                   if ((usp_inc == 1'b1)) 
                       usp <= (usp + 2'b10);
                       
                   else if ((usp_dec == 1'b1)) 
                       usp <= (usp - 2'b10);
                       
                   else if ((ssp_init == 1'b1)) 
                       ssp <= adata_in;
                       
                   else if ((ssp_inc == 1'b1)) 
                       ssp <= (ssp + 2'b10);
                       
                   else if ((ssp_dec == 1'b1)) 
                       ssp <= (ssp - 2'b10);
                       
                   
                   if (((((sp_add_displ == 1'b1) & (ar_wr == 1'b1)) & (ar_nr_a == 7)) & (sbit == 1'b1))) 
                       ssp <= (data_signed + displ_ext);
                       
                   else if ((((sp_add_displ == 1'b1) & (ar_wr == 1'b1)) & (ar_nr_a == 7))) 
                       usp <= (data_signed + displ_ext);
                       
                   else if (((sp_add_displ == 1'b1) & (sbit == 1'b1))) 
                       ssp <= (ssp + displ_ext);
                       
                   else if ((sp_add_displ == 1'b1)) 
                       usp <= (usp + displ_ext);
                       
                   
                   if (((ar_exg == 1'b1) & (op_mode == 5'b01001))) 
                       begin 
                           ar[ar_nr_b] <= ar[ar_nr_a];
                           ar[ar_nr_a] <= adata_in;
                       end
                       
                   else if (((ar_exg == 1'b1) & (op_mode == 5'b10001))) 
                       ar[ar_nr_b] <= adata_in;
                       
                   
                   if (((usp_cpy == 1'b1) & (dr == 1'b0))) 
                       begin 
                               if ((ar_nr_b < 7)) 
                                       usp <= ar[ar_nr_b];
                               else if ((sbit == 1'b1)) 
                                       usp <= ssp;

                               
                       end 
                   else if ((usp_cpy == 1'b1)) 
                       begin 
                               if ((ar_nr_b < 7)) 
                                       ar[ar_nr_b] <= usp;
                               else if ((sbit == 1'b1)) 
                                       ssp <= usp;

                               
                       end 
                   
                   if ((pc_wr == 1'b1)) 
                       pc <= data_signed;
                       
                   else if ((pc_init == 1'b1)) 
                       pc <= adata_in;
                       
                   else if ((pc_add_displ == 1'b1)) 
                       pc <= ((pc + displ_ext) + 2'b10);
                       
                   else if ((pc_inc == 1'b1)) 
                       pc <= ((pc + pc_tmp) + 2'b10);
                       
                   
                   
               end
               
           
       
    end// always 
       
   always @ (resetn or clk or op or ar_nr_a or ar_nr_b ) // begin 
           if ((resetn == 1'b0)) 
               begin 
                   begin :Block_Name_9
                       integer i;
                       for (i=0;i<=6;i=i+1) begin 
                           begin /* signal_assignment has moved. */ end 
                           
                       end //for
                   end //end Block
                   begin /* signal_assignment has moved. */ end 
                   begin /* signal_assignment has moved. */ end 
                   begin /* signal_assignment has moved. */ end 
               end
               
           
   // end always 
    

    generate 
        begin :Block_Name_10
            wire [0* 32: (6 +1)*32-1 ] ar_W ;
            genvar j;
                for ( j=0; j<=6;j=j+1) begin :Block_Name_11
                      assign ar_W [j * 32 +:32 ]=ar[j];
                end//for 
        end//block
    endgenerate 

endmodule
//--------------------------------------------------------------------
//--                                                              ----
//-- MC68000 compatible IP Core					                  ----
//--                                                              ----
//-- This file is part of the SUSKA ATARI clone project.          ----
//-- http://www.experiment-s.de                                   ----
//--                                                              ----
//-- Description:                                                 ----
//-- This model provides an opcode and bus timing compatible ip   ----
//-- core compared to Motorola's MC68000 microprocessor.          ----
//--                                                              ----
//-- This file is the package file of the ip core.                ----
//--                                                              ----
//--                                                              ----
//--                                                              ----
//--                                                              ----
//-- Author(s):                                                   ----
//-- - Wolfgang Foerster, wf@experiment-s.de; wf@inventronik.de   ----
//--                                                              ----
//-- Copyright (C) 2006 - 2011 Wolfgang Foerster                  ----
//--                                                              ----
//-- This source file is free software; you can redistribute it   ----
//-- and/or modify it under the terms of the GNU General Public   ----
//-- License as published by the Free Software Foundation; either ----
//-- version 2 of the License, or (at your option) any later      ----
//-- version.                                                     ----
//--                                                              ----
//-- This program is distributed in the hope that it will be      ----
//-- useful, but WITHOUT ANY WARRANTY; without even the implied   ----
//-- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ----
//-- PURPOSE.  See the GNU General Public License for more        ----
//-- details.                                                     ----
//--                                                              ----
//-- You should have received a copy of the GNU General Public    ----
//-- License along with this program; if not, write to the Free   ----
//-- Software Foundation, Inc., 51 Franklin Street, Fifth Floor,  ----
//-- Boston, MA 02110-1301, USA.                                  ----
//--                                                              ----
//--------------------------------------------------------------------
// 
// Revision History
// 
// Revision 2K6B  2006/12/24 WF
//   Initial Release.
// Revision 2K7A  2007/05/31 WF
//   Updated all modules.
// Revision 2K8A  2008/07/14 WF
//   See the 68K00 top level file.
// Revision 2K8B  2008/12/24 WF
//   See the 68K00 top level file.
// 

